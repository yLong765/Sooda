[{"categories":["阅读提炼"],"contents":"搜索空间的表示 最简单的寻路设计就是将图作为数据结构。图中包含多个节点，连接相邻的点组成边。图有多种表示方式，最简单的是邻接表\n游戏世界用图表示的方式 游戏世界用图来表示，有多种方法，一种简单的方法就是将世界区分为一个个正方形的格子（或者六边形）。如在《文明》策略游戏中的沙盘地图。而在不规则的地图中要么使用路点要么使用导航网格。\n寻路节点 光卡设计师在游戏世界中拜访AI可以到达的位置。这些点被解释为图中的节点（可手动和自动生成）\n缺点：AI只能在节点和边缘的位置移动。会有很多不可移动的位置，AI显得比较生硬\n导航网格 图上的节点实际上就是凸多边形。邻近节点就是简单的任意邻近凸多边形。意味着游戏世界区域可以通过少量的凸多边形表示。\n凸多边形内部任意位置都是可走的。意味着AI有了大量的空间可以行动。可返回更自然的路径\n启发式算法 游戏寻路的启发式算法有很多，启发式用公式$h(x)$表示，理想情况下启发式结果越接近真实越好。如果它的估算总是保证小于等于真实开销，那么这个启发式是可接受的。目前比较流行的启发式算法就是A*算法。不过还有贪婪最佳优先算法，Dijkstra算法等。这里只介绍A*算法\nA*算法 除了启发式 $h(x)$ 需要考虑，A又考虑了路径开销$g(x)$，所以A的节点开销等式为： $$ f(x) = g(x) + h(x) $$\n在当前节点搜索可到达的节点加入开放集合中，并从中选出开销最小的点放入关闭集合，如此往复。而$g(x)$的开销取决于父节点的$g(x)$的开销。这意味着父节点是可选的，$g(x)$的开销是可变得\n","date":"2022-01-19T21:58:45+08:00","permalink":"https://sooda.net.cn/post/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%AF%87/","section":"post","tags":["《游戏编程算法与技巧》","AI"],"title":"《游戏编程算法与技巧》人工智能篇"},{"categories":["阅读提炼"],"contents":"摄像机的基础属性 视场 观看世界的角度和广度，称为视场(FOV)。人双目并视大约能看到120°的视场，而剩余的视场在边缘能够发现运动，但不清晰\n如果视场变的太大就会有鱼眼效果，屏幕边缘会弯曲，类似于广角镜头\n高宽比 视口的宽度和高度的比率（如4:3、16:9等)\n摄像机的跟随实现 基础跟随 跟随在某个对象后方，保持固定距离，固定的俯视角摄像机\n// tPos: 目标位置 // tForward: 目标方向 // hDist: 水平跟随距离 // vDist: 垂直跟随距离 void BasucFollowCamera(GameObject target, float hDist, float vDist) { // 计算相机位置  Vector3 pos = target.position - target.forward * hDist + target.up * vDist; // 计算相机朝向  Vector3 cameraForward = tPos - pos; // 设置相机位置和朝向  //... } 弹性跟随相机 实现相机到相机目标位置的逐渐变化，可以理解为真实位置的相机和在基础跟随所要到达的理想位置中间有一个弹簧\nclass SpringCamera { float hDist, vDist; // 水平和垂直跟随距离  float springConstant; // 弹性常量：越高弹性越小  float dampConstant; // 阻尼常量：由弹性常量决定  Vector3 velocity, actualPosition; // 速度和摄像机真实位置  GameObject target; // 跟随目标  void init(GameObject _target, float _springConstant, float _hDist, float vDist) { target = _target; springConstant = _springConstant; hDist = _hDist; vDist = _vDist; // 计算阻尼常量  dampConstant = 2.0f * sqrt(springConstant); // 最开始真实位置 = 理想位置  actualPosition = target.position - target.forward * hDist + target.up * vDist; // 设置相机位置和朝向  //...  } void update(float deltaTime) { // 计算理想位置  Vector3 idealPosition = target.position - target.forward * hDist + target.up * vDist; // 计算理想位置到真实位置的向量  Vector3 displacement = actualPosition - idealPosition; // 根据弹簧计算加速度，然后积分  Vector3 springAccel = (-springConstant * displacement) - (dampConstant * velocity); velocity += springAccel * deltaTime; actualPosition += velocity * deltaTime; // 设置相机位置和朝向  //...  } } 样条摄像机 样条可以看作曲线，用线上的点定义的。使用她进行插值能够在整条曲线上得到平滑的效果。\nCatmull-Rom样条 邻近点进行插值。需要四个点，两个在前和后的控制点$P_0$和$P_3$，两个在中间的激活点$P_1$和$P_2$。计算t值介于0到1的所有样条公式(需要在控制点均匀的情况下使用)：\n\r$$ P(t) = 0.5 \\cdot (2 \\cdot P_1) + (-P_0 + P_2) \\cdot t + \\ (2 \\cdot P_0 - 5 \\cdot P_1 + 4 \\cdot P_2 - P_3) \\cdot t^2 + \\ (-P_0 + 3 \\cdot P_1 - 3 \\cdot P_2 + P_3) \\cdot t^3 $$\n\rclass CRSpline { Vector3[] controlPoints; // 样条点的动态数组  // 计算曲线  // start: t=0对应的控制点  Vector3 Compute(int start, float t) { // 检查start-1，start，start+1和start+2都要存在  Vector3 P0 = controlPoints[start - 1]; Vector3 P1 = controlPoints[start]; Vector3 P2 = controlPoints[start + 1]; Vector3 P3 = controlPoints[start + 2]; Vector3 position = 0.5 *((2*P1)+(-P0+P2)*t+ (2*P0-5*P1+4*P2-P3)*t*t+ (-P0+3*P-3*P2+P3)*t*t*t); return position; } } 这个公式也可用于计算t介于0到1之间的切线。首先，计算任意的t位置。然后，计算t加很小的增量$\\Delta t$的位置。就可以构造一个$p(t)$到$P(t+\\Delta t)$的向量并且正规化，从而近似得到切线。为了表示摄像机的移动方向。\n相机支持算法 相机碰撞检测 为了避免穿墙等问题，最简单的方式就是让从目标位置到相机进行光线检测，碰撞到物体则让相机位置改变到碰撞的物体之前。缺点是变换很突然。也可以用物理的方法做碰撞检测。\n让离相机过近的物体进行消失或者淡出，避免穿模。\n拣选（鼠标点击从相机发射射线） 鼠标的位置是屏幕空间中的一个2D点。将这个2D点从屏幕空间变换回世界空间去，称之为反投影。反投影为摄像机矩阵乘以投影矩阵的逆矩阵： $$ unprojection = (camera \\times projection)^{-1} $$ 但2D点不能乘以4x4矩阵，所以要线将2D点转换到齐次坐标系。z分量通常设置为0或1，取决于近平面或远平面。而作为一个点，w分量总为1.\nVector3 Unproject(Vector4 screenPoint, Matrix camera, Matrix projection) { // 计算逆矩阵  Matrix unprojection = camera * projection; unprojection.Invert(); return screenPoint * unprojection; } ","date":"2022-01-14T21:58:45+08:00","permalink":"https://sooda.net.cn/post/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7%E6%91%84%E5%83%8F%E6%9C%BA%E7%AF%87/","section":"post","tags":["《游戏编程算法与技巧》","摄像机"],"title":"《游戏编程算法与技巧》摄像机篇"},{"categories":["阅读提炼"],"contents":"平面 平面在游戏中倾向的数学定义：\n$$ P \\cdot \\hat{n} + d = 0 $$\n$P$是平面上任意一点，$\\hat{n}$是平面法线，$d$是平面到原点的最小距离\n// 平面的数据结构 struct Plane { Vector3 normal; float d; } 射线和线段 游戏中射线基本就是线段，因为基本不会让射线无限延伸下去。数学定义为：\n$$ R(t) = R_0 + \\vec{v}t $$\n$R_0$是起点，$\\vec{v}$是射线方向，$t$必须大于等于0。而在代码中的数据结构我们存两个点一个起点(startPoint)，一个终点(endPoint)。则$R_0$就是startPoint，$\\vec{v}$就是endPoint-startPoint，而$t$的取值就为0~1了\nstruct RayCast { Vector3 startPoint Vector3 endPoint } 碰撞几何体 包围球 通过中心点和半径表示\nclass ShpereCollider { Vector3 center; float radius; } 轴对齐包围盒(AABB) 每条边都与x轴或y轴平行的矩形，只能随轴旋转，多用于2D\nclass AABB2D { Vector2 min Vector2 max } 朝向包围盒OBB 可以自由旋转的类AABB包围盒，较复杂\n胶囊体 3D中为一个圆柱加上两个半圆，还可看作带半径的线段\nstruct Capsule2D { Vector2 startPoint; Vector2 endPoint; float radius; } 凸多边形 简称凸包。凸多边形比其他前几个方式效率低，但是更精准\n组合碰撞几何体 可用多个几何体，组合成一个近似于物体的碰撞盒。提高精度，效率相对来说毕竟高\n碰撞检测 球与球的交叉 如果两个球的半径之和小于两个球的距离则发生交叉\nvoid ShpereIntersection(ShpereCollider a, ShpereCollider b) { Vector3 centerVector = b.center - a.center; float distSquared = Dot(centerVector, centerVector); if (distSquared \u0026lt; ((a.radius + b.radius) * (a.radius + b.radius))) { return true; } return false; } AABB 与 AABB交叉 检测2D的两个AABB交叉的时候，检测没交叉会毕竟容易。有四种没交叉的方式\n A.max.x \u0026lt; B.min.x; B.max.x \u0026lt; A.min.x; A.max.y \u0026lt; B.min.y; B.max.y \u0026lt; A.min.y;  void AABBIntersection(AABB2D a, AABB2D b) { bool test = (a.max.x \u0026lt; b.min.x) || (B.max.x \u0026lt; A.min.x) || (A.max.y \u0026lt; B.min.y) || (B.max.y \u0026lt; A.min.y) return !test; } 线段与平面交叉 由上文的平面和线段公式可得，应为判断是否存在一个值$t$，使其线段与平面相交。\n $$ R(t) \\cdot \\hat{n} + d = 0 \\ (R_0 + \\vec{v}t) \\cdot \\hat{n} + d = 0 $$\n 解出t的值：\n $$ R_0 \\cdot \\hat{n} + (\\vec{v} \\cdot \\hat{n})t + d = 0 \\ (\\vec{v} \\cdot \\hat{n}) = -(R_0 \\cdot \\hat{n} + d) \\ t = \\frac{-(R_0 \\cdot \\hat{n} + d)}{\\vec{v} \\cdot \\hat{n}} $$\n $t$的取值范围应该为0~1，所以如果不在此范围则线段就不予平面相交\n如果线段和平面的法线点乘的结果为0，则表示线段与平面平行，肯定无交点\n// 将返回值包装成结构体 struct LSPlaneReturn { bool intersects; // 是否相交  Vector3 point; // 相交的点 } void LSPlaneIntersection(RayCast r, Plane p) { LSPlaneReturn retVal; retVal.intersects = false; Vector3 v = r.endPoint - r.startPoint; // 计算向量v  float vDotn = Dot(v, p.normal); if (vDotn != 0.0f) { // 说明线段和平面平行  t = -1 * (Dot(r.startPoint, p.normal) + p.d); t /= vDotn; if (t \u0026gt;= 0 \u0026amp;\u0026amp; t \u0026lt;= 1) { // 说明线段与平面有交点  retVal.intersects = true; retVal.point = r.startPoint + v * t; // 计算交点  } } else { // 测试起点是否在平面上  // ...  } return retVal; } 球与平面交叉 用球的重心建立于平面平行的另一个平面，判断两个平面的距离是否小于半径\nvoid SpherePlaneIntersection(SphereCollider s, Plane p) { float dSphere = -Dot(p.normal, s.center); return (abs(d - dSphere) \u0026lt; s.radius); } 球形扫掠体检测 前面几种检测方式都是即时碰撞检测。只能检测当前帧状态。但是物体每一帧都是会运动的，所以连续碰撞检测（CCD）是必须的。两个球星扫掠体的碰撞检查可以看作两个胶囊体的碰撞检查。此处就不做详细展开了\n响应碰撞 实际碰撞的响应事件应该抛出给应用层。比如Unity中有碰撞器和触发器，触发器不需要处理碰撞，而碰撞器则需要处理两个物体之间的物理状态。\n找到碰撞的准确位置 比如使用球与球的交叉来找出碰撞发生的时间。算出时间后回滚到那个时间点。\n碰撞后的速度 两个对象碰撞的时候，有一个恢复系统，衡量两个物体在碰撞后的反弹程度： $$ C_R = \\frac{碰撞后的相对速度}{碰撞前的相对速度} $$ 在弹性碰撞($C_R \u0026gt; 1$)的情况下，碰撞后的相对速度大于碰撞前的相对速度。在无弹性碰撞($C_R \u0026lt; 1$)就会导致碰撞后相对速度降低\n优化碰撞 如果游戏对象过多则会由过大的性能问题，一般用四叉树优化。将游戏世界递归切割成矩阵，直到每一个叶子节点引用一个对象\n基于物理的移动 游戏一般用经典物理，此处聚焦最基础部分：线性力学\n线性力学  力：是一种相互作用，可导致物体运动。有方向和大小。可用向量表示 质量：表示物体所害物质的量。质量越大，物体越难运动 牛顿第二定律：$F = m \\cdot a$。$F$是力，$m$是质量，$a$是加速度  游戏使用物理计算位置的时候，使用可变时间步长计算会很复杂。所以游戏基本都已固定步长来计算物理\n力的计算 游戏中常见的做法就是算出所有力的合力，然后除以质量算出加速度：\n 加速度 = 合力 / 质量  数值积分计算方式：\n 欧拉积分 半隐式欧拉积分：比欧拉积分更合理，更稳定 Verlet积分：比前两个准确，计算更昂贵 四阶Runge-Kutta：更准确，计算最昂贵  Verlet积分法 首先算出本次时间步长中点的速度值。然后将它看作平均速度计算整个步长的位置。然后，加速度根据力和质量计算出来，最终利用新的加速度在步长结束的时候计算出速度\nvoid Update(float deltaTime) { Vector3 sumOfForces = //... 计算所有力的合力  Vector3 avgVelocity = velocity + acceleration * deltaTime / 2.0f; position += avgVelocity * deltaTime; // 位置用平均速度计算  acceleration = sumOfForces / mass; // 计算新的加速度和位置  velocity = avgVelocity + acceleration * deltaTime / 2.0f; // 计算速度 } ","date":"2022-01-04T21:58:45+08:00","permalink":"https://sooda.net.cn/post/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7%E7%89%A9%E7%90%86%E7%AF%87/","section":"post","tags":["《游戏编程算法与技巧》","物理"],"title":"《游戏编程算法与技巧》物理篇"},{"categories":["阅读提炼"],"contents":"游戏输入 可分为两种：数字与模拟\n数字输入 只用两种状态：“按下”和“没有按”（例如键盘）\n如何实现一直按着的判断？ 同时跟踪上一帧和这一帧的状态，根据这两个状态来判断\n   上一帧状态 本帧状态 结论     释放 释放 一直释放   释放 按下 刚刚按下   按下 释放 刚刚释放   按下 按下 一直按下    伪代码：\nenum KeyState { StillReleased, JustPressed, JustReleased, StillPressed } lastState[256]; // 上一帧状态 currentState[256]; // 当前帧状态  // 每帧更新状态 void UpdateKeyboard() { lastState = currentState; currentState = GetKeyboardState(); // 获取当前状态 } // 通过keyCode获取KeyState KeyState GetKeyState(int keyCode) { if (lastState[keyCode]) if (currentState[keyCode]) return StillReleased; else return JustReleased; else if (currentState[keyCode]) return JustPressed; else return StillReleased; } 模拟输入 可返回某个数字的范围（如遥感）。但遥感的数值基本不会归零所以需要输入过滤，来消除偏差值。一般取遥感总值的10%为无效值。\n遥感的范围为-32768 ~ 32768。最终遥感映射到0 ~ 1的伪代码为：\nfloat deadZone = 3000 // 无效值 float maxValue = 32677 // 最大值  Vector2 GetJoy() { Vector2 joy = GetJoystickInput() // 获取遥感的输入  float length = joy.length() // 当前值长度  // 小于无效区域则没有输入  if (length \u0026lt; deadZone) { joy.x = 0 joy.y = 0 } else { // 计算无效区到最大值之间的百分比  float pct = (length - deadZone) / (maxValue - deadZone); // 正规化向量  joy = joy / length; joy = joy * maxValue * pct; } return joy } 移动设备输入 触摸和手势 大多数移动游戏都是通过多点触摸来实现虚拟手柄。还有一些游戏利用手势操作。自定义手势会比较难实现。Rubine算法就是一种流行的实现自定义手势检测的算法\n加速器 检测设备坐标系轴向上的加速度。总有一个常量添加到设备上：重力。意味着如果设备为空闲状态，加速器可以粗略地通过重力方向检测设备的朝向\n陀螺仪 检测设备关于设备轴向的旋转\n声音 声音同时播放的频道数量是有限的。所以声音应该有优先级数据\n原始数据 又类似Audacity等工具创建的原始音频文件\n 短音效一般存储为WAV格式或者其他无压缩文件格式 长音效一般会采用压缩文件格式比如MP3或者OGG  这两种音效一般会分别用两种方式播放\n 短音效（或常用音效）一般会直接加载到内存中缓存，需要时直接播放 长音效一般会以流方式加载。就是播放的同时加载  播放场景 声音的播放场景其实有很多，不同游戏有不同的情况。一般来说分为几种\n 短音效的事件触发播放（Unity的Animation中的事件元通道触发），比如脚步声 过长动画播放（Unity中的Timeline制作） 对话中的音频播放（一般会在对话树中抛出事件播放） 背景持续音  3D声音 2D音效是指没有位置相关的音效。而3D音效是由随着监听者和发射者距离增大而衰减的方式。\n对于3D声音监听者的摆放位置 第一人称游戏则很自然的跟随摄像机就能提供最好的效果。但是对于第三人称游戏放在摄像机位置会感觉很怪。放在人物位置如果一个声音在人物和摄像机直接则也会有问题。所以一个解决方式是放在摄像机和玩家之间，朝向跟随摄像机。具体还是得根据游戏类型来测试最优结果\n数字信号处理 广义上讲，数字信号处理（DSP）是计算机中表示的信号。在音频领域中，其表示加载音频后再修改之后得到的不同效果。\n为什么不把所有的效果离线处理，而要在运行时处理？ 可以节省内存 \n数字信号处理效果  高音偏移（多普勒偏移）：通过调整牝鹿增加或减小音效的音高 压缩机：缩小音量范围，导致很小的声音得到了加强，同时很大的声音得到了减小。 低通滤波器：通过删减频率减小音量  多普勒效应 由于声波在空气中传播需要时间，所以发声者靠近时，意味着声波都比前一个要早到。导致了频率的增加，就会有更高音高。所有与波相关的情况都会有多普勒效应\n声音遮挡 声音遮挡在声音不是直接由发射者传递到监听者的时候发生。声音遮挡主要就是低通滤波的结果，意味着高频率的声音的音量被移除了。这是因为低频率的音波比高频率的音波更容易传播。但是，声音遮挡的另一个输出就是整体音量的降低\n相似但是不同的想法就是声音衍射。通过声音衍射，声音可能不再是直线传播的了，但是还是有可能穿透障碍物\n检测遮挡和衍射的方法就是为发射者构造一系列指向监听者附近的弧形。如果没有一个能量到达，则就是遮挡。如果有一些能到达就是衍射。如果全部能到达就都不是。这个方法称之为Fresenl声学衍射\n","date":"2021-12-24T08:55:57+08:00","permalink":"https://sooda.net.cn/post/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7%E8%BE%93%E5%85%A5%E5%92%8C%E5%A3%B0%E9%9F%B3%E7%AF%87/","section":"post","tags":["《游戏编程算法与技巧》"],"title":"《游戏编程算法与技巧》输入和声音篇"},{"categories":["阅读提炼"],"contents":"闲话 近日读完了《游戏编程算法与技巧》这本书。更感觉是《游戏引擎架构》的缩略图。先阅读此书会对游戏开发有一个整体的认识与理解。适合需要了解游戏开发的初学者阅读\n此书对于我也是梳理游戏开发知识点的概括好书。对于此书会在重点部分做提炼。\n渲染基础 此部分只做简单的总结，网上已经有很多的好文章了。而此书作者也没有很详细的写这部分。毕竟这块要是讲细了够学一辈子了\n推荐一些好文（有兴趣可以看看我写的软渲染）\n 闫令琪老师的GAMES101课程 韦易笑老师的mini3d项目 韦易笑老师的RenderHelp项目 Dmitry V. Sokolov老师的tinyrender项目  双缓冲技术解决渲染撕裂 CRT显示器时代，所谓场消隐期（VBLANK）：喷枪从右下角移动到左上角所花费的时间\n渲染撕裂：显示器在绘制像素缓冲区中的内容时，游戏输出了新的渲染结果到像素缓冲区，导致渲染撕裂\n双缓冲技术：解决屏幕撕裂，用两块像素缓冲区，游戏交替的在这两块缓冲区中绘制\n垂直同步：让交换缓冲区的时机在场消隐期进行\n三缓冲技术：利用3个缓冲区，让画面更加平滑，但增加输入延迟\n画家算法 所有物体按照从后往前的顺序绘制。优点：绘制绝对正确（包括透明物体），缺点：overdraw高，效率慢\n3D渲染 为什么用三角形表示面片？\n 仅用3顶点表示的最简单的多边形 三角形总在一个面上 任何3D对象都可以简单地用细分三角面表示  网格：多个三角面组成\n软件光栅化 将3D模型正确渲染到2D颜色缓冲的算法\n3D模型经过4个主要坐标系空间转到最终的2D颜色缓冲中\n 模型（局部）坐标系：相对于模型自身的坐标系（角色模型一般为两脚中间） 世界坐标系：所有对象都相对于世界原点偏移 视角（摄像机）坐标系：将世界坐标系的模型变换到相对于摄像机的位置上 投影坐标系：将3D场景平铺到2D平面上得到的坐标系  除了上面的坐标系外，还有一个特殊的坐标系，就是齐次坐标系\n将4D坐标系应用在3D空间中，就被称为齐次坐标系。而第四个分量为w分量。如果w=0，则此齐次坐标是3D向量。而w=1，则表示此齐次坐标是3D的点\n矩阵变换 将模型在各个坐标系中转换所用的矩阵，就是矩阵变换。\n此处和之后所用的都为行向量。（OpenGL为列向量）  模型转世界坐标系 平移 将顶点移动一段距离，只作用在点上\n $$ T(t_x,t_y,t_z) = \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ t_x \u0026 t_y \u0026 t_z \u0026 1 \\end{bmatrix} $$  旋转 将顶点或向量相对于某个轴旋转（欧拉角旋转）\n旋转矩阵是正交的，就是说转置矩阵就是逆矩阵   $$ RotateX(\\theta) = \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 \\cos \\theta \u0026 - \\sin \\theta \u0026 0 \\\\ 0 \u0026 \\sin \\theta \u0026 \\cos \\theta \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} $$   $$ RotateY(\\theta) = \\begin{bmatrix} \\cos \\theta \u0026 0 \u0026 \\sin \\theta \u0026 0 \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ - \\sin \\theta \u0026 0 \u0026 \\cos \\theta \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} $$   $$ RotateZ(\\theta) = \\begin{bmatrix} \\cos \\theta \u0026 - \\sin \\theta \u0026 0 \u0026 0 \\\\ \\sin \\theta \u0026 \\cos \\theta \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} $$  缩放  $$ S(s_x,s_y,s_z) = \\begin{bmatrix} s_x \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 s_y \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 s_z \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} $$  按行矩阵应用矩阵变换，乘积的顺序应为：$ model2world = scale * rotation * translation $\n应先旋转在平移，因为旋转是相对于原点的，先旋转对象可自转。而后旋转则对象就是相对于世界坐标系原点旋转了。  观察矩阵(Look-At) $L$表示左边或x轴，$U$表示上方或y轴，$F$表示前方或z轴，$T$则是摄像机的平移\n $$ LookAt = \\begin{bmatrix} L_x \u0026 U_x \u0026 F_x \u0026 0 \\\\ L_y \u0026 U_y \u0026 F_y \u0026 0 \\\\ L_z \u0026 U_z \u0026 F_z \u0026 0 \\\\ T_x \u0026 T_y \u0026 T_z \u0026 1 \\end{bmatrix} $$  Matrix4x4 LookAt(Vector3 eye, Vector3 target, Vector3 Up) { Vector3 F = normalize(target - eye); Vector3 L = normalize(cross(Up, F)); Vector3 U = cross(F, L); Vector3 T; T.x = -dot(L, eye); T.y = -dot(U, eye); T.z = -dot(F, eye); //创建并返回观察矩阵  //... } 投影坐标系 正交投影  $$ Orthographic = \\begin{bmatrix} \\frac{2}{width} \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 \\frac{2}{height} \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 \\frac{1}{far - near} \u0026 0 \\\\ 0 \u0026 0 \u0026 \\frac{near}{far - near} \u0026 1 \\end{bmatrix} $$  透视投影  $$ Perspective=\\begin{bmatrix} \\cot \\frac{fov}{2} \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 \\frac{height}{width} \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 \\frac{far}{far - near} \u0026 1 \\\\ 0 \u0026 0 \u0026 \\frac{-near * far}{far - near} \u0026 0 \\end{bmatrix} $$  光照与着色 颜色 RGB颜色空间：将颜色分为红色，绿色和蓝色分量。\n色深：每个像素用多少位来存储（大部分每分量都为8位来存储，就是说每位有256种可能，共大约1600万种不同颜色）\n不透明度（用A表示，从而组成RGBA，一共32位）\n顶点属性 模型顶点上存储的额外信息\n 纹理映射：将2D图片映射到3D的三角形中  UV坐标：纹理的x坐标为u，y坐标为v   顶点法线：产生凹凸感  将拥有该顶点的三角形的法线取平均值，用于平滑模型（如圆形） 每个顶点存储自己的法线方向，用于棱角清晰的模型（如四边形）    顶点序：顶点的顺序，用于决定叉乘的值向量的朝向，保持全程一致就可。还可用于背面剔除\n光照  环境光：添加到场景中每一个物体上固定的光 方向光：没有位置，只指定光照方向的光 点光源：从某个点向四面八方射出的光照 聚光灯：将点光源限制在锥体内有光  Phong光照模型公式：\n $$ Phong 光照 = 环境光 + 漫反射 + 高光 $$   漫反射：光源作用于物体表面的主要反射。被所有方向光，点光源和聚光灯影响。 高光：物体表面的闪光点  // N = 物体表面法线 // eye = 摄像机位置 // pos = 物体表面位置 // a = 高光量 Vector3 V = normalize(eye - pos); Vector3 Phong = AmbientColor; // 环境光 foreach Light light in scene // 循环场景中所有的灯光  Vector3 L = normalize(light.pos - pos); // 从物体表面到光源  Phong += DiffuseColor * dot(N, L); // 漫反射光照强度  Vector3 R = normalize(reflect(-L, N)); // 计算-L关于N的反射  Phong += SpecularColor * pow(dot(R, V), a); // 高光强度 着色方式  平面着色：每个三角面只用一种颜色 Gouraud着色：通过顶点颜色插值填充（多边形数量越多越好） Phong着色：逐像素光照，针对每个像素单独计算  深度缓冲区 为场景的每个像素存储数据，与颜色缓冲一样，不过存储的是像素到摄像机的距离（深度）\n在每一帧渲染前会清空深度缓冲区（让所有像素无限远）。渲染过程中，深度会在像素着色器渲染前计算出来。如果比当前深度小，则绘制并写入新的深度\n透明对象的绘制 透明对象不适用于深度缓冲，如果透明物体比不透明物体深度浅，如果先画透明物体，则不透明物体就不会被绘制了\n为了解决此问题，应用深度测试先画所有的不透明物体，然后关闭深度测试，渲染所有透明物体。确保不透明物体背后的对象不进行渲染仍需进行深度检查\n大多数会采用24位或32位的深度缓冲区\n怎么解决像素重绘问题？ 先绘制深度pass，然后按照所得的深度缓冲结果计算光照pass\n利用剔除或者遮挡算法可消除在某些帧完全看不到的对象。类似的算法有二叉树分区算法（BSP），人口算法和遮挡体积等。\n（完）\n","date":"2021-12-22T15:57:24+08:00","permalink":"https://sooda.net.cn/post/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7%E6%B8%B2%E6%9F%93%E7%AF%87/","section":"post","tags":["《游戏编程算法与技巧》","渲染"],"title":"《游戏编程算法与技巧》渲染篇"},{"categories":["阅读提炼"],"contents":"闲话 近日读完了《游戏引擎架构》这本书，以前感觉读不完，但是每天慢慢的磨完了。闲下来时间提炼一下其中自我觉得比较关键的部分。因本人是做Unity开发的，所以会把书中所讲部分结合Unity引擎来总结。闲话不多说开始吧\n动画的基本构成 Unity的动画系统封装的已经非常好了，所以我们对其中的细节了解的少之又少。本文章着重在单个动画，骨骼，姿势，蒙皮的内存存储结构和应用方式\n角色动画的类型 在Unity中比较常用的动画为蒙皮/骨骼动画（三维）和精灵动画（二维）\n 赛璐璐动画（精灵动画）：用一张细小的位图，叠在全屏的背景影响之上而不会扰乱背景。常用于二维游戏动画（Unity中的Sprite贴图） 动画纹理：面向摄像机的四边形，并用一连串的位图连续播放。现今用于远景活低分辨率的物体 刚性阶层动画：将角色通过部位进行拆分建模并以层级进行约束。但问题是在关节处会出现裂缝 每顶点动画：移动每个顶点以产生更自然的动作（蛮力技术，数据量非常大。通常用于老式的离线渲染） 变形目标动画：每顶点动画的变种，也是制作每个顶点的位置。但制作少量的固定极端姿势在运行时将其混合（线性插值混合）。通常用于面部动画 蒙皮/骨骼动画：  骨骼：隐藏的刚性关节层阶结构（树结构）所构成 皮肤：绑定于骨骼上的圆滑三角形网格，顶点会按权重绑定至多个关节。当关节移动时，蒙皮可以自然的拉伸    为什么选择蒙皮/骨骼动画？ 以更少的数据量来达到更好的效果。通过加入约束：相对大量的顶点只能跟随相对少量的骨骼关节移动。来压缩顶点动画\n骨骼在内存中的表示 通常使用关节索引引用关节，子关节索引引用父关节。蒙皮三角形网格中，每个顶点索引引用其绑定关节\n// 关节数据的信息 struct Joint { Matrix4x3 inv_bind_pose; // 绑定姿势（蒙皮网格顶点绑定至骨骼时，关节的位置，定向及缩放）的逆变换  const char* name; // 关节名字（字符串或32位字符串散列表标识符）  U8 parent; // 父索引(0xFF代表根关节) }; struct Skeletion { U32 joint_count; // 关节数目  Joint* joint; // 关节数组 }; 姿势 把角色摆出一连串离散，静止的姿势，并以通常30或60个姿势每秒的速率显示，已产生动感。实际游戏会以相邻姿势进行插值\n绑定姿势：又称为T姿势。因此姿势四肢远离身体，较容易把顶点绑定至关节\n局部姿势 相对于父关节指定的，其仿射变换相对于父节点空间\n关节姿势：数学上就是一个仿射变换。4x4仿射变换矩阵$P_j$，此矩阵由平移矢量$T_j$，3x3对角缩放矩阵$S_j$，及3x3旋转矩阵$R_j$构成\n $$ p_j = \\begin{bmatrix} S_jR_j \u0026 0 \\\\ T_j \u0026 1 \\end{bmatrix} $$  整个骨骼的姿势：\n $$ P^{skel} = \\{ P_j \\} |_{j=0}^{N-1} $$  有些引擎不允许关节$S_j$缩放，有些引擎则必须为同一缩放。此优化能节省内存。并简化每个关节计算平截头体剔除及碰撞测试\n// 局部关节的内存表示 struct JointPose { Quaternion rot; // Q  Vector3 trans; // T  F32 scale; // S(仅为统一缩放) }; // 骨骼姿势：其所有关节姿势的集合 struct SkeletonPose { Skeleton* pSkeleton; // 骨骼 + 关节数量  JointPose* aLocalPose; // 多个局部关节姿势 } 全局姿势 关节姿势表示为相对于模型空间或世界空间。关节j的空间姿势(全局姿势)，可通过从该关节遍历至根节点并乘上其局部姿势\n任何关节$j$的全局姿势（关节至模型空间的变换）可写成：\n $$ P_{j \\rightarrow M} = \\prod_{i=j}^0 P_{i \\rightarrow p(i)} $$  // 全局关节的内存表示 struct SkeletonPose { Skeleton* pSkeleton; // 骨骼 + 关节数量  JointPose* aLocalPose; // 多个局部关节姿势  Matrix44* aGlobalPose; // 多个全局关节姿势 }; 动画片段  每个动画片段是为特定骨骼设计的，通常不会用于其他骨骼 动画重定目标：把为一个骨骼设计的动画，重订目标至不同骨骼  局部时间线 每个动画各自的时间线(AnimationClip)。时间索引$t$从$0$到$T$，$T$​为片段的持续时间\n动画师在指定的时间点上设定一些关键姿势或关键帧，然后对应不同的时间索引$t$会用线性差值计算采样\n帧：指一段时间，如1/30s或1/60s\n采样：代指某时间点\n相位：归一化表示时间单位，无论$T$多长，0代表动画开始，1代表结束\n全局时间线 每个角色都有一个全局时间线（类似于Unity的Timeline）\n播放动画可以简单的理解为把片段的局部时间映射到角色的全局时间\n调整播放速率：把片段置于全局时间线之时缩放其比例，加快2倍播放=缩放1/2的局部时间片段\n倒转播放：时间比例设置为-1\n动画片段映射到全局时间线需要的信息：\n 全局起始时间 播放速率R 持续时间T 循环次数N  同步动画  局部时间线同步动画：必须在完全相同的游戏帧数播放（实现比较麻烦） 全局时间线同步动画：只要开始时间相同就可以完全同步  内存中的表示方法 采样由骨骼中的每个关节的完整姿势所组成。存储为SQT格式\n如果缩放为标量。则一个未压缩的动画至多10个通道\n 平移：三维矢量$V=\\begin{bmatrix} V_x \u0026amp; V_y \u0026amp; V_z \\end{bmatrix}$ 旋转：四元数$Q=\\begin{bmatrix}Q_x \u0026amp; Q_y \u0026amp; Q_z \u0026amp; Q_w \\end{bmatrix}$ 缩放：标量$S$  struct AnimationSample { JointPose *aJointPose; // 关节姿势数组 }; struct AnimationClip { Skeleton *pSkeleton; // 骨骼关节（真实引擎中可能用骨骼标识符，而不是指针）  F32 framesPerSecond; // 帧每秒  // 注释：非循环动画为frameCount + 1，循环动画最后一采样等于第一个采样会略去  U32 frameCount; // 采样数目  AnimationSample *aSample; // 采样数组  bool isLooping; // 是否循环 } 通道函数（Unity的Animation编辑面板） 函数通道在整个动画片段的时间线上是圆滑连续的（除非故意编辑成不连续的，例如镜头切换）。而游戏引擎中基本只会在采样间进行线性插值，实际上用到的是连续函数的分段线性逼近\n可以加入额外的元通道数据。把游戏专用的信息编码，能和动画同步触发。如事件触发器（Unity的Animation面板中可触发事件）在动画脚步落地的时候播放声音\n定位器：利用Maya中的定位器（类似于Unity中模型中的一个子节点，如手中武器的父节点）用于记录物体的位置及定向\n蒙皮 把三维网格顶点联系至骨骼的过程\n蒙皮信息：每个顶点可绑定至一个或多个关节，绑定至一个关节则完全跟随此关节移动。若绑定多个关节则等于多个关节位置的加权平均\n 顶点绑定到（一个或多个）关节的索引 对于每个绑定的关节，提供一个权重因子（权重之和为1），表示该关节对最终顶点位置的影响力  对于绑定的关节数目通常限制为每顶点4关节，首先4个8位索引可包装位32位字。其次超过4个质量差别就没有明显提升了\n内存数据结构：\nstruct SkinnedVertex { float position[3];\t// (Px,Py,Pz)  float normal[3];\t// (Nx,Ny,Nz)  float u,v;\t// 纹理坐标uv  U8 jointIndex[4];\t// 关节索引  float jointWeight[3];\t// 关节权重，略去一个可用1-其他求得 } 蒙皮矩阵 将网格顶点从模型空间的原来位置（绑定姿势）变换至骨骼模型空间的当前姿势。非基变更变换\n顶点绑定至关节的位置时，在该关节空间中的位置时不变的。所以可把顶点于模型空间的绑定姿势位置转换至关节空间，再把关节空间移至当前姿势，最后把该顶点转回模型空间。这个转换过程结合的转换矩阵就是蒙皮矩阵\n单个关节的蒙皮矩阵 绑定姿势顶点的模型空间位置为$V_M^B$。矩阵$B_{j \\rightarrow M}$把点或者矢量从关节$j$空间变换至模型空间。则矩阵$B_{M \\rightarrow j}$就是从模型空间到关节$j$空间的变换矩阵。而$B_{M \\rightarrow j} = (B_{j \\rightarrow M})^{-1}$。则关节空间的顶点公式为：\n $$ V_j = V_M^B B_{M \\rightarrow j} = V_M^B(B_{j \\rightarrow M}^{-1}) $$  矩阵$C_{j \\rightarrow M}$表示关节空间转换到当前姿势的模型空间。则当前姿势顶点的模型空间位置$V_M^C$公式为：\n $$ V_M^C = V_jC_{j \\rightarrow M} $$  则联合后的蒙皮矩阵$K_j$为：\n $$ V_M^C = V_jC_{j \\rightarrow M} = V_M^B(B{j \\rightarrow M})^{-1}C_{j \\rightarrow M} = V_M^BK_j $$   $$ K_j =(B_{j \\rightarrow M})^{-1}C_{j \\rightarrow M} $$  多个关节的蒙皮矩阵 将单关节蒙皮矩阵扩展至多关节须计算矩阵调色板，就是一组蒙皮矩阵$K_j$，当中每个矩阵对应第j个关节。当渲染一个蒙皮网络时，矩阵调色板便要传送至渲染引擎。渲染器会为每个顶点查找调色板中合适的关节蒙皮矩阵，并用该矩阵把顶点从绑定姿势转换至当前姿势\n 当前姿势矩阵$C_{j \\rightarrow M}$需要每帧更新 绑定姿势的逆矩阵是常量，计算后缓存在骨骼信息中 动画引擎计算每个关节的局部姿势$C_{j \\rightarrow p(j)}$，然后转换至全局姿势$C_{j \\rightarrow M}$，最后把全局姿势乘以对应的绑定姿势逆矩阵$(B_{j \\rightarrow M})^{-1}$，以生成每个关节的蒙皮矩阵$K_j$  运算效率优化：将蒙皮矩阵调色板预先乘于物体的模型至世界变换。因为最终都要转换到世界空间，所以可以预处理。但在多角色同时播放单个动画的情况时不能这么做。此技术为动画实例\n（完）\n","date":"2021-11-07T17:14:24+08:00","permalink":"https://sooda.net.cn/post/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E5%8A%A8%E7%94%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9E%84%E6%88%90/","section":"post","tags":["《游戏引擎框架》","动画"],"title":"《游戏引擎架构》动画的基本构成"}]
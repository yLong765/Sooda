<!DOCTYPE html>
<html lang="cn">

<head>

<link rel="stylesheet" href="https://cdn.bootcss.com/KaTeX/0.16.0/katex.min.css">
<script defer src = "http://cdn.bootcss.com/KaTeX/0.16.0/katex.min.js"></script>
<script>
	var katex_config = {
		delimiters:[
			{left: "$$", right: "$$", display: true},
			{left: "$", right: "$", display: false}
		]
	};
</script>
<script defer src="https://cdn.bootcss.com/KaTeX/0.16.0/contrib/auto-render.min.js" onload="renderMathInElement(document.body, katex_config)"></script>


<meta charset="utf-8" />
<meta name="author" content="Alaya" />
<meta name="description" content="简简单单生活，安安静静编程" />
<meta name="keywords" content="" />
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="generator" content="Hugo 0.100.2" />

<link rel="canonical" href="https://ylong765.github.io/Sooda/post/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7%E8%BE%93%E5%85%A5%E5%92%8C%E5%A3%B0%E9%9F%B3%E7%AF%87/">
<meta property="og:title" content="《游戏编程算法与技巧》输入和声音篇" />
<meta property="og:description" content="此篇主要模拟输入和数字输入的区别和在游戏中声音需要注意的问题" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ylong765.github.io/Sooda/post/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7%E8%BE%93%E5%85%A5%E5%92%8C%E5%A3%B0%E9%9F%B3%E7%AF%87/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-12-24T08:55:57+08:00" />
<meta property="article:modified_time" content="2021-12-24T08:55:57+08:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="《游戏编程算法与技巧》输入和声音篇"/>
<meta name="twitter:description" content="此篇主要模拟输入和数字输入的区别和在游戏中声音需要注意的问题"/>


<meta itemprop="name" content="《游戏编程算法与技巧》输入和声音篇">
<meta itemprop="description" content="此篇主要模拟输入和数字输入的区别和在游戏中声音需要注意的问题"><meta itemprop="datePublished" content="2021-12-24T08:55:57+08:00" />
<meta itemprop="dateModified" content="2021-12-24T08:55:57+08:00" />
<meta itemprop="wordCount" content="194">
<meta itemprop="keywords" content="《游戏编程算法与技巧》," />

<link rel="stylesheet" href="https://ylong765.github.io/Sooda/css/layout.css" />


<link rel="stylesheet" href="https://ylong765.github.io/Sooda/css/default-dark.css" />




<title>


     《游戏编程算法与技巧》输入和声音篇 

</title>

</head>


<body>
<div class="main">
<header>

<div class="header-bar">

  <nav>
    <div class="siteTitle">
      <a href="https://ylong765.github.io/Sooda/">Sooda</a>
    </div> 

    
    
    <a class="nav-item" href="https://ylong765.github.io/Sooda/categories/"><div class="nav-item-title">Categories</div></a>
    
    <a class="nav-item" href="https://ylong765.github.io/Sooda/tags/"><div class="nav-item-title">Tags</div></a>
    
  </nav>
  <div class="font">
    简简单单生活，安安静静编程
  </div>
  

</div>


</header>


<article class="post">
    <h1 class="title"> 《游戏编程算法与技巧》输入和声音篇 </h1>
    <div class="content"> <h1 id="游戏输入">游戏输入</h1>
<p>可分为两种：<strong>数字</strong>与<strong>模拟</strong></p>
<h2 id="数字输入">数字输入</h2>
<p>只用两种状态：“按下”和“没有按”（例如键盘）</p>
<p>如何实现一直按着的判断？
同时跟踪上一帧和这一帧的状态，根据这两个状态来判断</p>
<table>
<thead>
<tr>
<th>上一帧状态</th>
<th>本帧状态</th>
<th>结论</th>
</tr>
</thead>
<tbody>
<tr>
<td>释放</td>
<td>释放</td>
<td>一直释放</td>
</tr>
<tr>
<td>释放</td>
<td>按下</td>
<td>刚刚按下</td>
</tr>
<tr>
<td>按下</td>
<td>释放</td>
<td>刚刚释放</td>
</tr>
<tr>
<td>按下</td>
<td>按下</td>
<td>一直按下</td>
</tr>
</tbody>
</table>
<p>伪代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">KeyState</span> {
</span></span><span style="display:flex;"><span>    StillReleased,
</span></span><span style="display:flex;"><span>    JustPressed,
</span></span><span style="display:flex;"><span>    JustReleased,
</span></span><span style="display:flex;"><span>    StillPressed
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>lastState[<span style="color:#ae81ff">256</span>];      <span style="color:#75715e">// 上一帧状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>currentState[<span style="color:#ae81ff">256</span>];   <span style="color:#75715e">// 当前帧状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 每帧更新状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">UpdateKeyboard</span>() {
</span></span><span style="display:flex;"><span>    lastState <span style="color:#f92672">=</span> currentState;
</span></span><span style="display:flex;"><span>    currentState <span style="color:#f92672">=</span> GetKeyboardState();  <span style="color:#75715e">// 获取当前状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 通过keyCode获取KeyState
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>KeyState <span style="color:#a6e22e">GetKeyState</span>(<span style="color:#66d9ef">int</span> keyCode) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (lastState[keyCode])
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (currentState[keyCode])
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> StillReleased;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> JustReleased;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (currentState[keyCode])
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> JustPressed;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> StillReleased;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="模拟输入">模拟输入</h2>
<p>可返回某个数字的范围（如遥感）。但遥感的数值基本不会归零所以需要输入过滤，来消除偏差值。一般取遥感总值的10%为无效值。</p>
<p>遥感的范围为-32768 ~ 32768。最终遥感映射到0 ~ 1的伪代码为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> deadZone <span style="color:#f92672">=</span> <span style="color:#ae81ff">3000</span>   <span style="color:#75715e">// 无效值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">float</span> maxValue <span style="color:#f92672">=</span> <span style="color:#ae81ff">32677</span>  <span style="color:#75715e">// 最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>Vector2 GetJoy() {
</span></span><span style="display:flex;"><span>    Vector2 joy <span style="color:#f92672">=</span> GetJoystickInput() <span style="color:#75715e">// 获取遥感的输入
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">float</span> length <span style="color:#f92672">=</span> joy.length() <span style="color:#75715e">// 当前值长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 小于无效区域则没有输入
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (length <span style="color:#f92672">&lt;</span> deadZone) {
</span></span><span style="display:flex;"><span>        joy.x <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        joy.y <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 计算无效区到最大值之间的百分比
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">float</span> pct <span style="color:#f92672">=</span> (length <span style="color:#f92672">-</span> deadZone) <span style="color:#f92672">/</span> (maxValue <span style="color:#f92672">-</span> deadZone);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 正规化向量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        joy <span style="color:#f92672">=</span> joy <span style="color:#f92672">/</span> length;
</span></span><span style="display:flex;"><span>        joy <span style="color:#f92672">=</span> joy <span style="color:#f92672">*</span> maxValue <span style="color:#f92672">*</span> pct;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> joy
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="移动设备输入">移动设备输入</h2>
<h3 id="触摸和手势">触摸和手势</h3>
<p>大多数移动游戏都是通过多点触摸来实现虚拟手柄。还有一些游戏利用手势操作。自定义手势会比较难实现。Rubine算法就是一种流行的实现自定义手势检测的算法</p>
<h3 id="加速器">加速器</h3>
<p>检测设备坐标系轴向上的加速度。总有一个常量添加到设备上：重力。意味着如果设备为空闲状态，加速器可以粗略地通过重力方向检测设备的朝向</p>
<h3 id="陀螺仪">陀螺仪</h3>
<p>检测设备关于设备轴向的旋转</p>
<h1 id="声音">声音</h1>
<p>声音同时播放的频道数量是有限的。所以声音应该有优先级数据</p>
<h2 id="原始数据">原始数据</h2>
<p>又类似Audacity等工具创建的原始音频文件</p>
<ul>
<li>短音效一般存储为WAV格式或者其他无压缩文件格式</li>
<li>长音效一般会采用压缩文件格式比如MP3或者OGG</li>
</ul>
<p>这两种音效一般会分别用两种方式播放</p>
<ul>
<li>短音效（或常用音效）一般会直接加载到内存中缓存，需要时直接播放</li>
<li>长音效一般会以流方式加载。就是播放的同时加载</li>
</ul>
<h2 id="播放场景">播放场景</h2>
<p>声音的播放场景其实有很多，不同游戏有不同的情况。一般来说分为几种</p>
<ul>
<li>短音效的事件触发播放（Unity的Animation中的事件元通道触发），比如脚步声</li>
<li>过长动画播放（Unity中的Timeline制作）</li>
<li>对话中的音频播放（一般会在对话树中抛出事件播放）</li>
<li>背景持续音</li>
</ul>
<h2 id="3d声音">3D声音</h2>
<p>2D音效是指没有位置相关的音效。而3D音效是由随着监听者和发射者距离增大而衰减的方式。</p>
<h3 id="对于3d声音监听者的摆放位置">对于3D声音监听者的摆放位置</h3>
<p>第一人称游戏则很自然的跟随摄像机就能提供最好的效果。但是对于第三人称游戏放在摄像机位置会感觉很怪。放在人物位置如果一个声音在人物和摄像机直接则也会有问题。所以一个解决方式是放在摄像机和玩家之间，朝向跟随摄像机。具体还是得根据游戏类型来测试最优结果</p>
<h2 id="数字信号处理">数字信号处理</h2>
<p>广义上讲，数字信号处理（DSP）是计算机中表示的信号。在音频领域中，其表示加载音频后再修改之后得到的不同效果。</p>
<center><font color = red>
为什么不把所有的效果离线处理，而要在运行时处理？
<p>可以节省内存
</font></center></p>
<h3 id="数字信号处理效果">数字信号处理效果</h3>
<ul>
<li><strong>高音偏移（多普勒偏移）</strong>：通过调整牝鹿增加或减小音效的音高</li>
<li><strong>压缩机</strong>：缩小音量范围，导致很小的声音得到了加强，同时很大的声音得到了减小。</li>
<li><strong>低通滤波器</strong>：通过删减频率减小音量</li>
</ul>
<h3 id="多普勒效应">多普勒效应</h3>
<p>由于声波在空气中传播需要时间，所以发声者靠近时，意味着声波都比前一个要早到。导致了频率的增加，就会有更高音高。所有与波相关的情况都会有多普勒效应</p>
<h3 id="声音遮挡">声音遮挡</h3>
<p>声音遮挡在声音不是直接由发射者传递到监听者的时候发生。声音遮挡主要就是低通滤波的结果，意味着高频率的声音的音量被移除了。这是因为低频率的音波比高频率的音波更容易传播。但是，声音遮挡的另一个输出就是整体音量的降低</p>
<p>相似但是不同的想法就是声音衍射。通过声音衍射，声音可能不再是直线传播的了，但是还是有可能穿透障碍物</p>
<p>检测遮挡和衍射的方法就是为发射者构造一系列指向监听者附近的弧形。如果没有一个能量到达，则就是遮挡。如果有一些能到达就是衍射。如果全部能到达就都不是。这个方法称之为<strong>Fresenl声学衍射</strong></p>
 </div>
    <footer class="post-footer">

  <div class="post-footer-data">
            
<div class="tags">
  
    
      <div class="tag">
        <a href="https://ylong765.github.io/Sooda/tags/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7">#《游戏编程算法与技巧》</a>
      </div>
    
  
</div>

    <div class="date"> 2021-12-24 </div>
    
    <hr>
            
<div class="categories">
  
  Published in:
    
      <div class="category">
        <a href="https://ylong765.github.io/Sooda/categories/%E9%98%85%E8%AF%BB%E6%8F%90%E7%82%BC">阅读提炼</a>
      </div>
    
  
</div>

            
<div class="series">
  
</div>

    
  </div>
</footer>


  
  



</article>

  <footer>

  <div class="social-links-footer">

  

  
  <a href="https://github.com/yLong765" target="_blank"><div class="social-link">GitHub</div></a>
  

  

  

  

  

</div>


  <div class="copyright"> Copyright © 2022, All Rights Reserved. </div>

  

  </footer>

</div> 

</body>
</html>


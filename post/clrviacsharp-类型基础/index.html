<!DOCTYPE html>
<html lang="cn">

<head>


    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad: true, theme: 'forest'});</script>

<meta charset="utf-8" />
<meta name="author" content="Alaya" />
<meta name="description" content="简简单单生活，安安静静编程" />
<meta name="keywords" content="" />
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="generator" content="Hugo 0.100.2" />

<link rel="canonical" href="https://sooda.net.cn/post/clrviacsharp-%E7%B1%BB%E5%9E%8B%E5%9F%BA%E7%A1%80/">
<meta property="og:title" content="C#类型基础" />
<meta property="og:description" content="对C#类型做基本的总结归纳。并补充一些平常不注意的细节问题。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sooda.net.cn/post/clrviacsharp-%E7%B1%BB%E5%9E%8B%E5%9F%BA%E7%A1%80/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-06-28T17:09:01+08:00" />
<meta property="article:modified_time" content="2022-06-28T17:09:01+08:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C#类型基础"/>
<meta name="twitter:description" content="对C#类型做基本的总结归纳。并补充一些平常不注意的细节问题。"/>

<meta itemprop="name" content="C#类型基础">
<meta itemprop="description" content="对C#类型做基本的总结归纳。并补充一些平常不注意的细节问题。"><meta itemprop="datePublished" content="2022-06-28T17:09:01+08:00" />
<meta itemprop="dateModified" content="2022-06-28T17:09:01+08:00" />
<meta itemprop="wordCount" content="112">
<meta itemprop="keywords" content="《CLR via C#》," />

<link rel="stylesheet" href="https://sooda.net.cn/css/layout.css" />


<link rel="stylesheet" href="https://sooda.net.cn/css/default-dark.css" />




<title>


     C#类型基础 

</title>

</head>


<body>
<div class="main">
<header>

<div class="header-bar">

  <nav>
    <div class="siteTitle">
      <a href="https://sooda.net.cn">Sooda</a>
    </div> 

    
    
    <a class="nav-item" href="https://sooda.net.cn/categories/"><div class="nav-item-title">Categories</div></a>
    
    <a class="nav-item" href="https://sooda.net.cn/tags/"><div class="nav-item-title">Tags</div></a>
    
  </nav>
  <div class="font">
    简简单单生活，安安静静编程
  </div>
  

</div>


</header>


<article class="post">
    <h1 class="title"> C#类型基础 </h1>
    <div class="content"> <h2 id="class基础">Class基础</h2>
<h3 id="systemobject">System.Object</h3>
<p>“运行时”所有的类型最终都从System.Object类型派生。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">// 隐式派生自Object</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 显式派生自Object</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> : System.Object {}
</span></span></code></pre></div><p>System.Object的public方法</p>
<ul>
<li>Equals：比较函数</li>
<li>GetHashCode：对象哈希值</li>
<li>ToString：转换成String类型对象</li>
<li>GetType：返回对象的类型</li>
</ul>
<p>System.Object的protected方法</p>
<ul>
<li>MemberwiseClone：创建类型的新实例，并将新对象的实例字段设置与this对象的实例字段完全一致。返回对新实例的引用</li>
<li>Finalize：垃圾回收阶段实际清理之前会调用此方法。</li>
</ul>
<h3 id="new操作符都做了什么工作">new操作符都做了什么工作</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>A a = <span style="color:#66d9ef">new</span> A(<span style="color:#e6db74">&#34;123&#34;</span>);
</span></span></code></pre></div><p>上面的代码中new操作符所作的事情：</p>
<ol>
<li>计算类型机器所有基类型(一直到System.Object)中定义的所有实例字段所需要的字节数。<strong>并加上每个对象都需要额外开销的类型对象指针(type object pointer)和同步块索引(sync block index)</strong> 。</li>
<li>从托管堆中分配1步骤中所计算的类型的字节数，从而分配对象的内存，分配的所有字节都设置为零(0)。</li>
<li>初始化对象的类型对象指针和同步块索引成员。</li>
<li>调用类型的实例构造器，传递在new调用中指定的实参。<strong>编译器会在构造函数(.ctor)中自动生成代码调用基类构造器</strong> 。最终都会调用System.Object的构造函数，但它什么都不做，单纯的返回。</li>
<li>返回指向新建对象的一个引用(或指针)</li>
</ol>
<h3 id="类型转换">类型转换</h3>
<p>CLR允许将对象转换为它的(实际)类型或者它的任何基类型。然而，将对象转换为派生类时，因可能转换失败，所以要求显示转换。</p>
<pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">graph LR;
    A(&#34;类型&#34;)--隐式转换--&gt;B(&#34;基类&#34;);
    A(&#34;类型&#34;)--显式转换--&gt;C(&#34;派生类&#34;);
</code></pre><h4 id="is-和-as">is 和 as</h4>
<p>is操作符用于检查是否兼容于指定类型，如果对象引用null则总是返回false</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>Object o = <span style="color:#66d9ef">new</span> Object();
</span></span><span style="display:flex;"><span>o <span style="color:#66d9ef">is</span> Object;    <span style="color:#75715e">// 返回true</span>
</span></span><span style="display:flex;"><span>o <span style="color:#66d9ef">is</span> A;         <span style="color:#75715e">// 返回false</span>
</span></span></code></pre></div><p>as操作符用于检查是否兼容于指定类型，并进行转换。如果兼容则返回对于类型，不兼容则返回null。(判断null比检查是否兼容于指定类型快)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>A a = o <span style="color:#66d9ef">as</span> A;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (a != <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="using操作符的作用">using操作符的作用</h3>
<ul>
<li>using指令指示编译器尝试为类型名称附加不同的前缀，直到找到匹配项</li>
<li>允许为类型或命名空间创建别名。如<code>using obj = System.Object;</code></li>
</ul>
<h3 id="运行时的细节">运行时的细节</h3>
<p>例如我有如下两个方法M1和M2。观察这两个方法执行时线程栈中内存的分配变化。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> M1() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">string</span> name = <span style="color:#e6db74">&#34;Yang&#34;</span>;
</span></span><span style="display:flex;"><span>    M2(name);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> M2(<span style="color:#66d9ef">string</span> name) {
</span></span><span style="display:flex;"><span>    Int32 length = name.Length();
</span></span><span style="display:flex;"><span>    Int32 tally;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>首先我们的程序应该运行在一个Windows进程上。进程可能又会有多个线程。每个线程创建时会分配到1M的栈空间。栈空间用于向方法传递实参，方法内部的定义的局部变量也在栈上。栈从高位内存地址向低位内存地址构建。</li>
</ul>
<p><img src="images/clrviacsharp/1.png" alt="123"></p>
 </div>
    <footer class="post-footer">

  <div class="post-footer-data">
            
<div class="tags">
  
    
      <div class="tag">
        <a href="https://sooda.net.cn/tags/clr-via-c">#《CLR via C#》</a>
      </div>
    
  
</div>

    <div class="date"> 2022-06-28 </div>
    
    <hr>
            
<div class="categories">
  
  Published in:
    
      <div class="category">
        <a href="https://sooda.net.cn/categories/%E9%98%85%E8%AF%BB%E6%8F%90%E7%82%BC">阅读提炼</a>
      </div>
    
  
</div>

            
<div class="series">
  
</div>

    
  </div>
</footer>


  
  



</article>

  <footer>

  <div class="social-links-footer">

  

  
  <a href="https://github.com/yLong765" target="_blank"><div class="social-link">GitHub</div></a>
  

  

  

  

  

</div>


  <div class="copyright"> Copyright © 2022, All Rights Reserved. </div>

  

  </footer>

</div> 

<script>
  Array.from(document.getElementsByClassName('language-mermaid')).forEach(el => {
    el.parentElement.outerHTML = `<div class="mermaid">${el.innerText}</div>`
  })
</script>
<style>
   
  .mermaid svg {
      display: block;
      margin: auto;
  }
  </style>

</body>
</html>


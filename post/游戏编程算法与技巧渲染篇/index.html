<!DOCTYPE html>
<html lang="zh-cn">

<head>


<meta charset="utf-8" />
<meta name="author" content="Alaya" />
<meta name="description" content="简简单单生活，安安静静编程" />
<meta name="keywords" content="" />
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="generator" content="Hugo 0.100.2" />

<link rel="canonical" href="https://sooda.net.cn/post/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7%E6%B8%B2%E6%9F%93%E7%AF%87/">
<meta property="og:title" content="《游戏编程算法与技巧》渲染篇" />
<meta property="og:description" content="此篇主要介绍最近本的渲染知识点" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sooda.net.cn/post/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7%E6%B8%B2%E6%9F%93%E7%AF%87/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-12-22T15:57:24+08:00" />
<meta property="article:modified_time" content="2021-12-22T15:57:24+08:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="《游戏编程算法与技巧》渲染篇"/>
<meta name="twitter:description" content="此篇主要介绍最近本的渲染知识点"/>


<meta itemprop="name" content="《游戏编程算法与技巧》渲染篇">
<meta itemprop="description" content="此篇主要介绍最近本的渲染知识点"><meta itemprop="datePublished" content="2021-12-22T15:57:24+08:00" />
<meta itemprop="dateModified" content="2021-12-22T15:57:24+08:00" />
<meta itemprop="wordCount" content="521">
<meta itemprop="keywords" content="《游戏编程算法与技巧》,渲染," />

<link rel="stylesheet" href="https://sooda.net.cn/css/layout.css" />


<link rel="stylesheet" href="https://sooda.net.cn/css/default-dark.css" />




<title>


     《游戏编程算法与技巧》渲染篇 

</title>

</head>


<body>
<div class="main">
<header>

<div class="header-bar">

  <nav>
    <div class="siteTitle">
      <a href="https://sooda.net.cn/">Sooda</a>
    </div> 

    
    
    <a class="nav-item" href="https://sooda.net.cn/categories/"><div class="nav-item-title">Categories</div></a>
    
    <a class="nav-item" href="https://sooda.net.cn/tags/"><div class="nav-item-title">Tags</div></a>
    
  </nav>
  
  简简单单生活，安安静静编程
  

</div>


</header>


<article class="post">
    <h1 class="title"> 《游戏编程算法与技巧》渲染篇 </h1>
    <div class="content"> <h1 id="闲话">闲话</h1>
<p>近日读完了《游戏编程算法与技巧》这本书。更感觉是《游戏引擎架构》的缩略图。先阅读此书会对游戏开发有一个整体的认识与理解。适合需要了解游戏开发的初学者阅读</p>
<p>此书对于我也是梳理游戏开发知识点的概括好书。对于此书会在重点部分做提炼。</p>
<h1 id="渲染基础">渲染基础</h1>
<p>此部分只做简单的总结，网上已经有很多的好文章了。而此书作者也没有很详细的写这部分。毕竟这块要是讲细了够学一辈子了</p>
<p>推荐一些好文（有兴趣可以看看我写的<a href="https://gitee.com/GeekL/sheep-render">软渲染</a>）</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1X7411F744">闫令琪老师的GAMES101课程</a></li>
<li><a href="https://github.com/skywind3000/mini3d">韦易笑老师的mini3d项目</a></li>
<li><a href="https://github.com/skywind3000/RenderHelp">韦易笑老师的RenderHelp项目</a></li>
<li><a href="https://github.com/ssloy/tinyrenderer">Dmitry V. Sokolov老师的tinyrender项目</a></li>
</ul>
<h2 id="双缓冲技术解决渲染撕裂">双缓冲技术解决渲染撕裂</h2>
<p>CRT显示器时代，所谓场消隐期（VBLANK）：喷枪从右下角移动到左上角所花费的时间</p>
<p>渲染撕裂：显示器在绘制像素缓冲区中的内容时，游戏输出了新的渲染结果到像素缓冲区，导致渲染撕裂</p>
<p>双缓冲技术：解决屏幕撕裂，用两块像素缓冲区，游戏交替的在这两块缓冲区中绘制</p>
<p>垂直同步：让交换缓冲区的时机在场消隐期进行</p>
<p>三缓冲技术：利用3个缓冲区，让画面更加平滑，但增加输入延迟</p>
<h2 id="画家算法">画家算法</h2>
<p>所有物体按照从后往前的顺序绘制。优点：绘制绝对正确（包括透明物体），缺点：overdraw高，效率慢</p>
<h2 id="3d渲染">3D渲染</h2>
<p>为什么用三角形表示面片？</p>
<ul>
<li>仅用3顶点表示的最简单的多边形</li>
<li>三角形总在一个面上</li>
<li>任何3D对象都可以简单地用细分三角面表示</li>
</ul>
<p>网格：多个三角面组成</p>
<h3 id="软件光栅化">软件光栅化</h3>
<p>将3D模型正确渲染到2D颜色缓冲的算法</p>
<p>3D模型经过4个主要坐标系空间转到最终的2D颜色缓冲中</p>
<ul>
<li>模型（局部）坐标系：相对于模型自身的坐标系（角色模型一般为两脚中间）</li>
<li>世界坐标系：所有对象都相对于世界原点偏移</li>
<li>视角（摄像机）坐标系：将世界坐标系的模型变换到相对于摄像机的位置上</li>
<li>投影坐标系：将3D场景平铺到2D平面上得到的坐标系</li>
</ul>
<p>除了上面的坐标系外，还有一个特殊的坐标系，就是齐次坐标系</p>
<p>将4D坐标系应用在3D空间中，就被称为齐次坐标系。而第四个分量为w分量。如果w=0，则此齐次坐标是3D向量。而w=1，则表示此齐次坐标是3D的点</p>
<h4 id="矩阵变换">矩阵变换</h4>
<p>将模型在各个坐标系中转换所用的矩阵，就是矩阵变换。</p>
<!-- raw HTML omitted -->
<h4 id="模型转世界坐标系">模型转世界坐标系</h4>
<h5 id="平移">平移</h5>
<p>将顶点移动一段距离，只作用在点上</p>
<p>$$
T(t_x,t_y,t_z) = \begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \newline
0 &amp; 1 &amp; 0 &amp; 0 \newline
0 &amp; 0 &amp; 1 &amp; 0 \newline
t_x &amp; t_y &amp; t_z &amp; 1
\end{bmatrix}
$$</p>
<h5 id="旋转">旋转</h5>
<p>将顶点或向量相对于某个轴旋转（欧拉角旋转）</p>
<!-- raw HTML omitted -->
<p>$$
RotateX(\theta) = \begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \newline
0 &amp; \cos \theta &amp; - \sin \theta &amp; 0 \newline
0 &amp; \sin \theta &amp; \cos \theta &amp; 0 \newline
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
$$</p>
<p>$$
RotateY(\theta) = \begin{bmatrix}
\cos \theta &amp; 0 &amp; \sin \theta &amp; 0 \newline
0 &amp; 1 &amp; 0 &amp; 0 \newline
- \sin \theta &amp; 0 &amp; \cos \theta &amp; 0 \newline
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
$$</p>
<p>$$
RotateZ(\theta) = \begin{bmatrix}
\cos \theta &amp; - \sin \theta &amp; 0 &amp; 0 \newline
\sin \theta &amp; \cos \theta &amp; 0 &amp; 0 \newline
0 &amp; 0 &amp; 1 &amp; 0 \newline
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
$$</p>
<h5 id="缩放">缩放</h5>
<p>$$
S(s_x,s_y,s_z) = \begin{bmatrix}
s_x &amp; 0 &amp; 0 &amp; 0 \newline
0 &amp; s_y &amp; 0 &amp; 0 \newline
0 &amp; 0 &amp; s_z &amp; 0 \newline
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
$$</p>
<p>按行矩阵应用矩阵变换，乘积的顺序应为：$ model2world = scale * rotation * translation $</p>
<!-- raw HTML omitted -->
<h4 id="观察矩阵look-at">观察矩阵(Look-At)</h4>
<p>$L$表示左边或x轴，$U$表示上方或y轴，$F$表示前方或z轴，$T$则是摄像机的平移</p>
<p>$$
LookAt = \begin{bmatrix}
L_x &amp; U_x &amp; F_x &amp; 0 \newline
L_y &amp; U_y &amp; F_y &amp; 0 \newline
L_z &amp; U_z &amp; F_z &amp; 0 \newline
T_x &amp; T_y &amp; T_z &amp; 1
\end{bmatrix}
$$</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Matrix4x4 <span style="color:#a6e22e">LookAt</span>(Vector3 eye, Vector3 target, Vector3 Up) {
</span></span><span style="display:flex;"><span>    Vector3 F <span style="color:#f92672">=</span> normalize(target <span style="color:#f92672">-</span> eye);
</span></span><span style="display:flex;"><span>    Vector3 L <span style="color:#f92672">=</span> normalize(cross(Up, F));
</span></span><span style="display:flex;"><span>    Vector3 U <span style="color:#f92672">=</span> cross(F, L);
</span></span><span style="display:flex;"><span>    Vector3 T;
</span></span><span style="display:flex;"><span>    T.x <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>dot(L, eye);
</span></span><span style="display:flex;"><span>    T.y <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>dot(U, eye);
</span></span><span style="display:flex;"><span>    T.z <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>dot(F, eye);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//创建并返回观察矩阵
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h4 id="投影坐标系">投影坐标系</h4>
<h5 id="正交投影">正交投影</h5>
<p>$$
Orthographic = \begin{bmatrix}
\frac{2}{width} &amp; 0 &amp; 0 &amp; 0 \newline
0 &amp; \frac{2}{height} &amp; 0 &amp; 0 \newline
0 &amp; 0 &amp; \frac{1}{far - near} &amp; 0 \newline
0 &amp; 0 &amp; \frac{near}{far - near} &amp; 1
\end{bmatrix}
$$</p>
<h5 id="透视投影">透视投影</h5>
<p>$$
Perspective=\begin{bmatrix}
\cot \frac{fov}{2} &amp; 0 &amp; 0 &amp; 0 \newline
0 &amp; \frac{height}{width} &amp; 0 &amp; 0 \newline
0 &amp; 0 &amp; \frac{far}{far - near} &amp; 1 \newline
0 &amp; 0 &amp; \frac{-near * far}{far - near} &amp; 0
\end{bmatrix}
$$</p>
<h4 id="光照与着色">光照与着色</h4>
<h5 id="颜色">颜色</h5>
<p>RGB颜色空间：将颜色分为红色，绿色和蓝色分量。</p>
<p>色深：每个像素用多少位来存储（大部分每分量都为8位来存储，就是说每位有256种可能，共大约1600万种不同颜色）</p>
<p>不透明度（用A表示，从而组成RGBA，一共32位）</p>
<h5 id="顶点属性">顶点属性</h5>
<p>模型顶点上存储的额外信息</p>
<ul>
<li>纹理映射：将2D图片映射到3D的三角形中
<ul>
<li>UV坐标：纹理的x坐标为u，y坐标为v</li>
</ul>
</li>
<li>顶点法线：产生凹凸感
<ul>
<li>将拥有该顶点的三角形的法线取平均值，用于平滑模型（如圆形）</li>
<li>每个顶点存储自己的法线方向，用于棱角清晰的模型（如四边形）</li>
</ul>
</li>
</ul>
<p>顶点序：顶点的顺序，用于决定叉乘的值向量的朝向，保持全程一致就可。还可用于背面剔除</p>
<h5 id="光照">光照</h5>
<ul>
<li>环境光：添加到场景中每一个物体上固定的光</li>
<li>方向光：没有位置，只指定光照方向的光</li>
<li>点光源：从某个点向四面八方射出的光照</li>
<li>聚光灯：将点光源限制在锥体内有光</li>
</ul>
<p>Phong光照模型公式：</p>
<!-- raw HTML omitted -->
<ul>
<li>漫反射：光源作用于物体表面的主要反射。被所有方向光，点光源和聚光灯影响。</li>
<li>高光：物体表面的闪光点</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// N = 物体表面法线
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// eye = 摄像机位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// pos = 物体表面位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// a = 高光量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Vector3 V <span style="color:#f92672">=</span> normalize(eye <span style="color:#f92672">-</span> pos);
</span></span><span style="display:flex;"><span>Vector3 Phong <span style="color:#f92672">=</span> AmbientColor;   <span style="color:#75715e">// 环境光
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>foreach Light light in scene    <span style="color:#75715e">// 循环场景中所有的灯光
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Vector3 L <span style="color:#f92672">=</span> normalize(light.pos <span style="color:#f92672">-</span> pos); <span style="color:#75715e">// 从物体表面到光源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Phong <span style="color:#f92672">+=</span> DiffuseColor <span style="color:#f92672">*</span> dot(N, L);  <span style="color:#75715e">// 漫反射光照强度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Vector3 R <span style="color:#f92672">=</span> normalize(reflect(<span style="color:#f92672">-</span>L, N)); <span style="color:#75715e">// 计算-L关于N的反射
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Phong <span style="color:#f92672">+=</span> SpecularColor <span style="color:#f92672">*</span> pow(dot(R, V), a); <span style="color:#75715e">// 高光强度
</span></span></span></code></pre></div><h6 id="着色方式">着色方式</h6>
<ul>
<li>平面着色：每个三角面只用一种颜色</li>
<li>Gouraud着色：通过顶点颜色插值填充（多边形数量越多越好）</li>
<li>Phong着色：逐像素光照，针对每个像素单独计算</li>
</ul>
<h4 id="深度缓冲区">深度缓冲区</h4>
<p>为场景的每个像素存储数据，与颜色缓冲一样，不过存储的是像素到摄像机的距离（深度）</p>
<p>在每一帧渲染前会清空深度缓冲区（让所有像素无限远）。渲染过程中，深度会在像素着色器渲染前计算出来。如果比当前深度小，则绘制并写入新的深度</p>
<h5 id="透明对象的绘制">透明对象的绘制</h5>
<p>透明对象不适用于深度缓冲，如果透明物体比不透明物体深度浅，如果先画透明物体，则不透明物体就不会被绘制了</p>
<p>为了解决此问题，应用深度测试先画所有的不透明物体，然后关闭深度测试，渲染所有透明物体。确保不透明物体背后的对象不进行渲染仍需进行深度检查</p>
<p>大多数会采用24位或32位的深度缓冲区</p>
<p>怎么解决像素重绘问题？
先绘制深度pass，然后按照所得的深度缓冲结果计算光照pass</p>
<p>利用剔除或者遮挡算法可消除在某些帧完全看不到的对象。类似的算法有二叉树分区算法（BSP），人口算法和遮挡体积等。</p>
<p>（完）</p>
 </div>
    <footer class="post-footer">

  <div class="post-footer-data">
            
<div class="tags">
  
    
      <div class="tag">
        <a href="https://sooda.net.cn/tags/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7">#《游戏编程算法与技巧》</a>
      </div>
    
      <div class="tag">
        <a href="https://sooda.net.cn/tags/%E6%B8%B2%E6%9F%93">#渲染</a>
      </div>
    
  
</div>

    <div class="date"> 2021-12-22 </div>
    
    <hr>
            
<div class="categories">
  
  Published in:
    
      <div class="category">
        <a href="https://sooda.net.cn/categories/%E9%98%85%E8%AF%BB%E6%8F%90%E7%82%BC">阅读提炼</a>
      </div>
    
  
</div>

            
<div class="series">
  
</div>

    
  </div>
</footer>


  
  



</article>

  <footer>

  <div class="social-links-footer">

  

  
  <a href="https://github.com/yLong765" target="_blank"><div class="social-link">GitHub</div></a>
  

  

  

  

  

</div>


  <div class="copyright"> Copyright © 2022, All Rights Reserved. </div>

  

  </footer>

</div> 

</body>
</html>


<!DOCTYPE html>
<html lang="cn">

<head>


<meta charset="utf-8" />
<meta name="author" content="Alaya" />
<meta name="description" content="简简单单生活，安安静静编程" />
<meta name="keywords" content="" />
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="generator" content="Hugo 0.100.2" />

<link rel="canonical" href="https://sooda.net.cn/post/clr_via_c#summary/">
<meta property="og:title" content="CLR_via_C#_Summary" />
<meta property="og:description" content="CLR的执行模型 公共语言运行时(Common Language Runtime, CLR)是一个可由多种编程语言使用的“运行时”。CLR的核心功能(比如内存管理、程序集加载、安全性、异常处理和线程同步)可由面向CLR的所有语言使用。
不同编程语言的意义？ 可将编译器视为语法检查器和“正确代码”分析器。它们检查代码，确定写的一切都有意义，并输出对其意图进行描述的代码。
无论任何用哪个编译器，最终编译的结果都是托管模块(managed module)。托管模块是标准的32位Microsoft Windows可移植执行(Portable Executable, PE32)或64位(PE32&#43;)文件
托管程序集总是利用Windows的数据执行保护(Data Execution Prevention, DEP)和地址空间布局随机化(Address Space Layout Randomization, ASLR)来增强系统安全性
托管模块的组成部分 说明 PE32或PE32&#43;头 标准Windows PE文件头，类似于“公共对象文件格式”(Common Oject File Format, COFF)头。 CLR头 包含使这个模块成为托管模块的信息(可由CLR和一些实用程序进行解释)。 元数据 每个托管模块都包含元数据表。主要由两种表：一种描述源代码中定义的类型和成员，另一种描述源代码引用的类型和成员。 IL(中间语言)代码 编译器编译源代码时生成的代码。在运行时，CLR将IL编程成本机CPU指令 本机代码编译器(native code compilers)生成的是面向特定CPU架构的代码。
每个面向CLR的编译器生成的都是IL代码。IL有时候成为托管代码(managed code)，因为CLR管理它的执行。
除了IL，每个面向CLR的编译器还要在每个托管模块中生成完整的元数据(metadata)。
元数据的用途：
避免编译时对原生C/C&#43;&#43;头和库文件的需求，因为在实现类型/成员的IL代码文件中，已包含有关引用类型/成员的全部信息。编译器直接从托管模块读取元数据。 “智能感知”(IntelliSense)技术会解析元数据，告诉你一个类型提供了哪些方法、属性、事件和字段。对于方法，还能告诉其参数 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sooda.net.cn/post/clr_via_c#summary/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-06-16T11:01:40+08:00" />
<meta property="article:modified_time" content="2022-06-16T11:01:40+08:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="CLR_via_C#_Summary"/>
<meta name="twitter:description" content="CLR的执行模型 公共语言运行时(Common Language Runtime, CLR)是一个可由多种编程语言使用的“运行时”。CLR的核心功能(比如内存管理、程序集加载、安全性、异常处理和线程同步)可由面向CLR的所有语言使用。
不同编程语言的意义？ 可将编译器视为语法检查器和“正确代码”分析器。它们检查代码，确定写的一切都有意义，并输出对其意图进行描述的代码。
无论任何用哪个编译器，最终编译的结果都是托管模块(managed module)。托管模块是标准的32位Microsoft Windows可移植执行(Portable Executable, PE32)或64位(PE32&#43;)文件
托管程序集总是利用Windows的数据执行保护(Data Execution Prevention, DEP)和地址空间布局随机化(Address Space Layout Randomization, ASLR)来增强系统安全性
托管模块的组成部分 说明 PE32或PE32&#43;头 标准Windows PE文件头，类似于“公共对象文件格式”(Common Oject File Format, COFF)头。 CLR头 包含使这个模块成为托管模块的信息(可由CLR和一些实用程序进行解释)。 元数据 每个托管模块都包含元数据表。主要由两种表：一种描述源代码中定义的类型和成员，另一种描述源代码引用的类型和成员。 IL(中间语言)代码 编译器编译源代码时生成的代码。在运行时，CLR将IL编程成本机CPU指令 本机代码编译器(native code compilers)生成的是面向特定CPU架构的代码。
每个面向CLR的编译器生成的都是IL代码。IL有时候成为托管代码(managed code)，因为CLR管理它的执行。
除了IL，每个面向CLR的编译器还要在每个托管模块中生成完整的元数据(metadata)。
元数据的用途：
避免编译时对原生C/C&#43;&#43;头和库文件的需求，因为在实现类型/成员的IL代码文件中，已包含有关引用类型/成员的全部信息。编译器直接从托管模块读取元数据。 “智能感知”(IntelliSense)技术会解析元数据，告诉你一个类型提供了哪些方法、属性、事件和字段。对于方法，还能告诉其参数 "/>


<meta itemprop="name" content="CLR_via_C#_Summary">
<meta itemprop="description" content="CLR的执行模型 公共语言运行时(Common Language Runtime, CLR)是一个可由多种编程语言使用的“运行时”。CLR的核心功能(比如内存管理、程序集加载、安全性、异常处理和线程同步)可由面向CLR的所有语言使用。
不同编程语言的意义？ 可将编译器视为语法检查器和“正确代码”分析器。它们检查代码，确定写的一切都有意义，并输出对其意图进行描述的代码。
无论任何用哪个编译器，最终编译的结果都是托管模块(managed module)。托管模块是标准的32位Microsoft Windows可移植执行(Portable Executable, PE32)或64位(PE32&#43;)文件
托管程序集总是利用Windows的数据执行保护(Data Execution Prevention, DEP)和地址空间布局随机化(Address Space Layout Randomization, ASLR)来增强系统安全性
托管模块的组成部分 说明 PE32或PE32&#43;头 标准Windows PE文件头，类似于“公共对象文件格式”(Common Oject File Format, COFF)头。 CLR头 包含使这个模块成为托管模块的信息(可由CLR和一些实用程序进行解释)。 元数据 每个托管模块都包含元数据表。主要由两种表：一种描述源代码中定义的类型和成员，另一种描述源代码引用的类型和成员。 IL(中间语言)代码 编译器编译源代码时生成的代码。在运行时，CLR将IL编程成本机CPU指令 本机代码编译器(native code compilers)生成的是面向特定CPU架构的代码。
每个面向CLR的编译器生成的都是IL代码。IL有时候成为托管代码(managed code)，因为CLR管理它的执行。
除了IL，每个面向CLR的编译器还要在每个托管模块中生成完整的元数据(metadata)。
元数据的用途：
避免编译时对原生C/C&#43;&#43;头和库文件的需求，因为在实现类型/成员的IL代码文件中，已包含有关引用类型/成员的全部信息。编译器直接从托管模块读取元数据。 “智能感知”(IntelliSense)技术会解析元数据，告诉你一个类型提供了哪些方法、属性、事件和字段。对于方法，还能告诉其参数 "><meta itemprop="datePublished" content="2022-06-16T11:01:40+08:00" />
<meta itemprop="dateModified" content="2022-06-16T11:01:40+08:00" />
<meta itemprop="wordCount" content="44">
<meta itemprop="keywords" content="《CLR via C#》," />

<link rel="stylesheet" href="https://sooda.net.cn/css/layout.css" />


<link rel="stylesheet" href="https://sooda.net.cn/css/default-dark.css" />




<title>


     CLR_via_C#_Summary 

</title>

</head>


<body>
<div class="main">
<header>

<div class="header-bar">

  <nav>
    <div class="siteTitle">
      <a href="https://sooda.net.cn/">Sooda</a>
    </div> 

    
    
    <a class="nav-item" href="https://sooda.net.cn/categories/"><div class="nav-item-title">Categories</div></a>
    
    <a class="nav-item" href="https://sooda.net.cn/tags/"><div class="nav-item-title">Tags</div></a>
    
  </nav>
  
  简简单单生活，安安静静编程
  

</div>


</header>


<article class="post">
    <h1 class="title"> CLR_via_C#_Summary </h1>
    <div class="content"> <h1 id="clr的执行模型">CLR的执行模型</h1>
<p>公共语言运行时(Common Language Runtime, CLR)是一个可由多种编程语言使用的“运行时”。CLR的核心功能(比如内存管理、程序集加载、安全性、异常处理和线程同步)可由面向CLR的所有语言使用。</p>
<p>不同编程语言的意义？
可将编译器视为语法检查器和“正确代码”分析器。它们检查代码，确定写的一切都有意义，并输出对其意图进行描述的代码。</p>
<p>无论任何用哪个编译器，最终编译的结果都是<!-- raw HTML omitted -->托管模块(managed module)<!-- raw HTML omitted -->。托管模块是标准的32位Microsoft Windows可移植执行(Portable Executable, PE32)或64位(PE32+)文件</p>
<p>托管程序集总是利用Windows的数据执行保护(Data Execution Prevention, DEP)和地址空间布局随机化(Address Space Layout Randomization, ASLR)来增强系统安全性</p>
<table>
<thead>
<tr>
<th>托管模块的组成部分</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>PE32或PE32+头</td>
<td>标准Windows PE文件头，类似于“公共对象文件格式”(Common Oject File Format, COFF)头。</td>
</tr>
<tr>
<td>CLR头</td>
<td>包含使这个模块成为托管模块的信息(可由CLR和一些实用程序进行解释)。</td>
</tr>
<tr>
<td>元数据</td>
<td>每个托管模块都包含元数据表。主要由两种表：一种描述源代码中定义的类型和成员，另一种描述源代码引用的类型和成员。</td>
</tr>
<tr>
<td>IL(中间语言)代码</td>
<td>编译器编译源代码时生成的代码。在运行时，CLR将IL编程成本机CPU指令</td>
</tr>
</tbody>
</table>
<p>本机代码编译器(native code compilers)生成的是面向特定CPU架构的代码。</p>
<p>每个面向CLR的编译器生成的都是IL代码。IL有时候成为托管代码(managed code)，因为CLR管理它的执行。</p>
<p>除了IL，每个面向CLR的编译器还要在每个托管模块中生成完整的元数据(metadata)。</p>
<p>元数据的用途：</p>
<ul>
<li>避免编译时对原生C/C++头和库文件的需求，因为在实现类型/成员的IL代码文件中，已包含有关引用类型/成员的全部信息。编译器直接从托管模块读取元数据。</li>
<li>“智能感知”(IntelliSense)技术会解析元数据，告诉你一个类型提供了哪些方法、属性、事件和字段。对于方法，还能告诉其参数</li>
</ul>
 </div>
    <footer class="post-footer">

  <div class="post-footer-data">
            
<div class="tags">
  
    
      <div class="tag">
        <a href="https://sooda.net.cn/tags/clr-via-c">#《CLR via C#》</a>
      </div>
    
  
</div>

    <div class="date"> 2022-06-16 </div>
    
    <hr>
            
<div class="categories">
  
  Published in:
    
      <div class="category">
        <a href="https://sooda.net.cn/categories/%E9%98%85%E8%AF%BB%E6%8F%90%E7%82%BC">阅读提炼</a>
      </div>
    
  
</div>

            
<div class="series">
  
</div>

    
  </div>
</footer>


  
  



</article>

  <footer>

  <div class="social-links-footer">

  

  
  <a href="https://github.com/yLong765" target="_blank"><div class="social-link">GitHub</div></a>
  

  

  

  

  

</div>


  <div class="copyright"> Copyright © 2022, All Rights Reserved. </div>

  

  </footer>

</div> 

</body>
</html>


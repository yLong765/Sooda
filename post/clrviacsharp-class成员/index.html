<!DOCTYPE html>
<html lang="cn">

<head>


<meta charset="utf-8" />
<meta name="author" content="Alaya" />
<meta name="description" content="简简单单生活，安安静静编程" />
<meta name="keywords" content="" />
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="generator" content="Hugo 0.100.2" />

<link rel="canonical" href="https://sooda.net.cn/post/clrviacsharp-class%E6%88%90%E5%91%98/">
<meta property="og:title" content="C# Class成员" />
<meta property="og:description" content="C#中class的成员的介绍、用法和注意事项" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sooda.net.cn/post/clrviacsharp-class%E6%88%90%E5%91%98/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-07-27T15:20:36+08:00" />
<meta property="article:modified_time" content="2022-07-27T15:20:36+08:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C# Class成员"/>
<meta name="twitter:description" content="C#中class的成员的介绍、用法和注意事项"/>

<meta itemprop="name" content="C# Class成员">
<meta itemprop="description" content="C#中class的成员的介绍、用法和注意事项"><meta itemprop="datePublished" content="2022-07-27T15:20:36+08:00" />
<meta itemprop="dateModified" content="2022-07-27T15:20:36+08:00" />
<meta itemprop="wordCount" content="746">
<meta itemprop="keywords" content="《CLR via C#》," />

<link rel="stylesheet" href="https://sooda.net.cn/css/layout.css" />


<link rel="stylesheet" href="https://sooda.net.cn/css/default-dark.css" />




<title>


     C# Class成员 

</title>

</head>


<body>
<div class="main">
<header>

<div class="header-bar">

  <nav>
    <div class="siteTitle">
      <a href="https://sooda.net.cn">Sooda</a>
    </div> 

    
    
    <a class="nav-item" href="https://sooda.net.cn/categories/"><div class="nav-item-title">Categories</div></a>
    
    <a class="nav-item" href="https://sooda.net.cn/tags/"><div class="nav-item-title">Tags</div></a>
    
  </nav>
  <div class="font">
    简简单单生活，安安静静编程
  </div>
  

</div>


</header>


<article class="post">
    <h1 class="title"> C# Class成员 </h1>
    <div class="content"> <h2 id="类型成员基础">类型成员基础</h2>
<ul>
<li>常量：数据恒定不变的符号。</li>
<li>字段：只读或可读/可写的数据值。</li>
<li>实例构造器：将新<strong>对象</strong>的实例字段初始化的特殊方法</li>
<li>类型构造器：将<strong>类型</strong>的静态字段初始化的特殊方法。</li>
<li>方法：更改或查询类型或对象状态的函数。<strong>作用于类型成为静态方法，作用于对象为实例方法</strong>。</li>
<li>操作符重载：实际是方法，定义了当操作符作用于对象时，应该如何操作对象。</li>
<li>转换操作符：定义如何隐式或显式将对象从一种类型转型为另一种类型的方法。</li>
<li>属性：设置或查询类型或对象的逻辑状态。<strong>作用于类型为静态属性，作用域对象为实例属性</strong>。</li>
<li>事件：静态事件允许<strong>类型</strong>向一个或多个静态或实例方法发送通知。实例事件允许<strong>对象</strong>向一个或多个静态或实例方法发送通知。</li>
<li>类型：可以定义其他嵌套类型。</li>
</ul>
<h3 id="常量">常量</h3>
<p>定义常量符号时，值必须能在编译时确定。编译器将常量值保存到程序集元数据中。意味着只能定义编译器可识别的基元类型常量。非基元类型的常量变量只能为null。</p>
<p>编译器会在定义常量的程序集元数据中查找该符号，提取常量值并嵌入IL代码中。所以<strong>运行时没有任何额外内存分配，但是不能取常量地址或引用传递常量</strong>。</p>
<p><strong>C#不允许常量设置为static，因为常量总隐式设置为static</strong>。</p>
<blockquote>
<p>如果希望在运行时从一个程序集中提取另一个程序集中的值，那么不应该使用常量，而应该使用<strong>readonly</strong>字段。</p>
</blockquote>
<h3 id="字段">字段</h3>
<p>字段是一种数据成员，容纳了一个值类型的实例或对一个引用类型的引用。</p>
<p>CLR支持<strong>类型(静态)字段</strong>和<strong>实例(非静态)字段</strong>。类型字段所需的动态内存是在类型对象中分配的，而<strong>类型对象是在类型加载到一个AppDomain时创建的</strong>。<strong>类型加载到AppDmain的时机又是在引用该类型的任何方法首次进行JIT编译的时候</strong>。实例字段容纳字段数据所需的动态内存是在构造类型的实例时分配的。</p>
<h4 id="字段修饰符">字段修饰符</h4>
<table>
<thead>
<tr>
<th>CLR术语</th>
<th>C#术语</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Static</td>
<td>static</td>
<td>类型(静态)字段</td>
</tr>
<tr>
<td>Instance</td>
<td>(默认)</td>
<td>实例(非静态)字段</td>
</tr>
<tr>
<td>InitOnly</td>
<td>readonly</td>
<td>只能有一个构造方法中的代码写入(但可利用反射修改readonly字段)</td>
</tr>
<tr>
<td>Volatile</td>
<td>volatile</td>
<td>编译器、CLR和硬件不会对访问这种字段的代码执行“线程不安全”的优化措施</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>：当某个字段时引用类型，并且该字段呗标记为readonly时，不可改变的是引用，而非字段引用的对象。</p>
</blockquote>
<h3 id="方法">方法</h3>
<h4 id="实例构造器引用类型">实例构造器(引用类型)</h4>
<p>实例构造器是初始化类型的实例的特殊方法。构造器方法在“方法定义元数据表”中始终叫做.ctor。<strong>创建引用类型的实例时，首先为实例的数据字段分配内存，然后把内存部分归零(保证没有被构造器显式赋值的所有字段都为0或null值)，接着初始化对象的附加字段(类型对象指针和同步索引块)，最后调用类型的实例构造器来设置对象的初始状态</strong>。</p>
<h5 id="注意事项">注意事项</h5>
<ul>
<li>实例构造器永远不能被继承。所以不能使用:virtual，new，override，sealed，abstract修饰符。</li>
<li>如果没有显式定义构造器，C#编译器则会默认定义一个(无参)构造器。这个构造器只是简单的调用了基类的构造器
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//等价于：</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> A() : <span style="color:#66d9ef">base</span>() {}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>如果类的修饰符为abstract，则编译器生成的默认构造器的可访问性就为protected。否则为public。</li>
<li>如果类的修饰符为static，则编译器不会生成默认构造器。</li>
<li>为了使代码“可验证”，类的实例构造器在访问从基类继承的任何字段之前，必须先调动基类的构造器。如果派生类的构造器没有显式调用一个基类构造器，C#编译器会自动生成对默认的基类构造器的调用。</li>
<li>极少数可以在不调用实例构造器的前提下创建类型的实例。比如Object的MemberwiseClone方法、或反序列化时。</li>
<li><strong>不要在构造函数中调用虚方法</strong>。</li>
</ul>
<p><strong>C#编译器以“内联”(嵌入)方式初始化实例字段。在每个构造器方法开始的位置，包含类字段中直接赋值的代码。在其后会插入对基类构造器的调用。然后再插入构造函数的代码</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> { }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> a = <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> b = <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> A() {
</span></span><span style="display:flex;"><span>        b = <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// C#编译器编译后的代码为</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> : B {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> a;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> b;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> A() {
</span></span><span style="display:flex;"><span>        a = <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        b = <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 调用父类构造器</span>
</span></span><span style="display:flex;"><span>        b = <span style="color:#ae81ff">2</span>; <span style="color:#75715e">// b会被重复赋值</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>优化：在声明字段是就赋值会导致再每个构造器中都会加入初始化代码。可以不在声明字段时赋值。用一个构造函数初始化，并在其他构造函数中调用那个构造函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> a;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> b;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> A() {
</span></span><span style="display:flex;"><span>      a = <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> A(<span style="color:#66d9ef">int</span> b) : <span style="color:#66d9ef">this</span>() { <span style="color:#75715e">// 调用空参构造函数</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">this</span>.b = b;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></blockquote>
<h4 id="实例构造器值类型">实例构造器(值类型)</h4>
<p>CLR总允许创建值类型的实例，并且没有办法阻止值类型的实例化。所以值类型其实并不需要定义构造器，C#编译器根本不会为值类型内联(嵌入)默认的构造器。</p>
<p>CLR不会为包含在引用类型中的每个值类型字段都主动调用构造器。但是，值类型的字段会初始化为0或null。</p>
<p>CLR允许为值类型定义构造器，但<strong>必须显式调用</strong>才会执行。</p>
<p><strong>C#编译器不允许值类型定义无参构造函数</strong>。但CLR允许。</p>
<p>值类型的任何构造器都<strong>必须初始化值类型的全部字段</strong>。</p>
<blockquote>
<p>注意：当值类型嵌套到引用类型中时，才保证初始化为0或null。基于栈的值类型字段则无此保证。但任何基于栈的值类型字段都必须在读取之前赋值。</p>
</blockquote>
<blockquote>
<p>注意：在值类型的构造器中，this代码值类型本身的一个实例，用new创建的值类型的一个实例可以赋给this。在new的过程中，会将所有字段置为0或null。而在引用类型的构造器中，this被认为是只读的，不可赋值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">A</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> A(<span style="color:#66d9ef">int</span> x) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">this</span> = <span style="color:#66d9ef">new</span> A();
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">this</span>.x = x;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></blockquote>
<h4 id="类型构造器">类型构造器</h4>
<p>类型构造器可用于接口(C#编译器不允许)、引用类型和值类型。类型构造器是设置类型的初始状态。类型<strong>默认没有定义类型构造器</strong>。<strong>只能定义一个</strong>。<strong>不能有参数</strong>。<strong>必须标记为static</strong>。<strong>总是私有</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> A() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// A被首次访问时，执行这里的代码</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">B</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> B() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// B被首次访问时，执行这里的代码</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="类型构造器的调用">类型构造器的调用</h5>
<p>JIT编译一个方法时，会查看代码中都引用了哪些类型。任何一个类型定义了类型构造器，JIT编译器都会检查针对当前AppDomain，是否已经执行了这个类型构造器。如果未执行，JIT编译器会在它生成的本机代码中添加对类型构造器的调用。如果已执行，JIT编译器就不添加对它的调用。</p>
<p>在调用类型构造器时，为了保证类型构造器只执行一次。调用线程需要获取互斥线程同步锁。如果多个线程试图同时调用某个类型的静态构造器则只有一个线程可以获得锁，其他线程会被阻塞(blocked)。当线程执行完毕后等待的线程被唤起发现类型构造器已经执行过。因此不会在执行，直接返回。</p>
<blockquote>
<p>注意：可以在值类型中定义类型构造器，但是不要那么做，因为CLR有时不会调用值类型的类型构造器。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">A</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">static</span> A() {
</span></span><span style="display:flex;"><span>      Console.WriteLine(<span style="color:#e6db74">&#34;这行代码不会被执行&#34;</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>A[] a = <span style="color:#66d9ef">new</span> A[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>a[<span style="color:#ae81ff">0</span>].x = <span style="color:#ae81ff">123</span>;
</span></span><span style="display:flex;"><span>Console.WriteLine(a[<span style="color:#ae81ff">0</span>].x);
</span></span></code></pre></div></blockquote>
<blockquote>
<p>注意：因为类型构造器是线程安全级的，所以非常适合在类型构造器中初始化单例对象。</p>
</blockquote>
<blockquote>
<p>注意：类型构造器中只能访问类型的静态字段</p>
</blockquote>
<h4 id="操作符重载方法">操作符重载方法</h4>
<p>CLR规范操作符重载方法必须是<strong>public</strong>和<strong>static</strong>方法。C#要求操作符重载方法至少有一个参数类型与当前定义这个方法的类型相同。为了更快的找到要使用哪个操作符方法。</p>
<p>编译器看到源码中出现一个操作符时，会检查是否有一个操作数的类型定义了名为操作符对应特殊方法名的方法，而且该方法的参数兼容于操作数的类型。如果存在则调用，不存在则报错。</p>
<h4 id="转换操作符方法">转换操作符方法</h4>
<p>如果源类型或目标类型不是基元类型，编译器会生成强制转换代码，检查源对象的类型和目标类型(或者从目标类型派生的其他类型)是不是相同。转换操作符是将一种类型转换成另一种类型的方法。CLR规范转换操作符重载方法必须是public和static方法。C#要求器参数和返回类型二者必有一个与定义转换方法的类型相同。</p>
<p>implicit关键字告诉编译器为了生成代码来调用方法，不需要再源代码中进行显式转型。explicit关键字告诉编译器只有发现了显式转型时，才调用方法。</p>
<h4 id="扩展方法">扩展方法</h4>
<p>扩展方法允许定义一个静态方法，并用实例方法的语法来调用。</p>
<h5 id="扩展方法的调用过程">扩展方法的调用过程</h5>
<p>如下代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>StringBuilder sb = <span style="color:#66d9ef">new</span> StringBuilder();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> index = sb.IndexOf(<span style="color:#e6db74">&#39;X&#39;</span>);
</span></span></code></pre></div><p>首先检查StringBuilder类或者它的任何基类是否提供了获取单个Char参数、名为IndexOf的实例方法。如果有，就生成IL代码来调用，否则继续<strong>检查是否有任何静态类定义的名为IndexOf的静态方法，方法的第一个参数类型与当前调用方法的哪个表达式的类型匹配，而且该类型必须用this关键字标识</strong>。</p>
<h5 id="规则和原则">规则和原则</h5>
<ul>
<li>可以为接口类型、委托类型和枚举类型定义扩展方法。</li>
<li>C#只支持扩展方法，不支持扩展属性、事件、操作符等。</li>
<li>扩展方法必须在非泛型的静态类中声明。而且，类名没有限制，但是扩展方法必须要有一个参数，而且只第一个参数使用this关键字。</li>
<li>C#编译器在静态类中查找扩展方法时，要求静态类本身必须具有文件作用域(不能嵌套在某个类中)。</li>
<li>由于静态类可以取任何名字，所以C#编译器要花一定时间来寻找扩展方法，它<strong>必须检查文件作用域中的所有静态类，并扫描所有静态方法来查找一个匹配</strong>。为了增强性能，C#编译器要求“导入”扩展方法。</li>
<li>多个静态类可以定义相同的方法。如果编译器发现会报错。</li>
<li><strong>扩展方法扩展一个类型时，同时也扩展了派生类型</strong>。</li>
<li><strong>会存在覆盖问题，如果一个类原本没有实例方法，并定义了一个扩展方法，未来加入了同名的实例方法则会直接调用实例方法。并且没有报错</strong>。</li>
</ul>
<h5 id="extensionattribute">ExtensionAttribute</h5>
<p>如果用this关键字标记的某个静态方法的第一个参数，编译器就会在内部想该方法应用一个ExtensionAttribute特性。该特性会生成到文件的元数据中持久的保存下来。相当于一个搜索表。</p>
<h4 id="分部方法">分部方法</h4>
<p>利用partial关键字，可以将类或方法的实现分为两个文件</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">partial</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">partial</span> <span style="color:#66d9ef">void</span> Func();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 另一个文件中的代码</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">partial</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">partial</span> <span style="color:#66d9ef">void</span> Func() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 具体代码</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="规则和原则-1">规则和原则</h5>
<ul>
<li>如果没有实现分部方法，编译器不会生成任何代表分部方法的元数据。</li>
<li>只能在分部类或结构中声明。</li>
<li>分部方法的返回类型始终为void，任何参数都不能用out标记。因为方法在运行时可能不存在，所以不能将变量初始化为方法也许会返回的东西。但可以用ref，可以是泛型方法，可以时实例或静态方法。也可以标记unsafe。</li>
<li>分部方法的声明和实现必须具有完全一致的签名。如果两者都定制了特性，则会合并特性。应用于参数的任何特性也会合并。</li>
<li>分部方法总为private。</li>
</ul>
<h3 id="参数">参数</h3>
<h4 id="规则与原则">规则与原则</h4>
<ul>
<li>向方法传递实参时，编译器从左到右的顺序对实参进行求值。</li>
<li>有默认值的参数必须放在没有默认值的所有参数之后。但参数数组必须放在所有参数(包括有默认值的参数)之后，而且数组不能有默认值。</li>
<li>默认值必须是编译时能确认的常量。包括基元类型、枚举类型，以及能设为null的任何引用类型。可用default或new关键字来表达默认值。这两种关键字会生成完全一样的IL代码。</li>
<li>ref或out关键字的标识不能设置默认值。</li>
<li>实参可以按照任意顺序传递，但命名实参只能出现在实参列表的尾部。</li>
<li>可按名称将实参传给没有默认值的参数，但所有必须的实参都必须传递。</li>
<li>C#不允许省略逗号之间的实参。例如<code>Func(1, ,2)</code>。</li>
</ul>
<h4 id="引用传参out和ref">引用传参(out和ref)</h4>
<p>CLR不区分out和ref，但C#编译器区分。</p>
<p>参数用out标记，表明不指望调用者在调用方法前就初始化了对象。</p>
<p>参数用ref标记，表示调用者必须在调用方法前初始化对象。</p>
<blockquote>
<p>注意：</p>
<ul>
<li>两个重载方法只有out和ref的区别规则不合法，因为对于CLR他们是一样的。</li>
<li>对于以传引用的方式给方法的变量，他的类型必须与方法签名中声明的类型相同(不能向上转型)。</li>
</ul>
</blockquote>
<blockquote>
<p>注意：可变参数方法对性能会有所影响(除非显式传递null)。因为数组对象需要在堆上分配，元素必须初始化，而且需要垃圾回收。</p>
</blockquote>
<h4 id="参数和返回值的设计规范">参数和返回值的设计规范</h4>
<ul>
<li>声明方法的参数类型时，应尽量指定最弱的类型，宁愿要接口也不要基类型。因为弱类型适合更广泛的情形。</li>
<li>声明方法的返回类型时，应尽量指定最强的类型。</li>
<li>如果想保持一定的灵活性，在将来更改方法返回的东西，可以选择一个较弱的返回类型。</li>
</ul>
<p>总结：其实就是看情况而定。不确定就偏弱类型。</p>
<h3 id="属性">属性</h3>
<p>允许源代码用简化的语法来调用方法。CLR支持两种属性：无参属性和有参属性(C#中的索引器)。<strong>属性本质就是调用一个方法</strong>。</p>
<h4 id="无参属性">无参属性</h4>
<p>CLR<strong>支持静态、实例、抽象和虚属性</strong>。属性<strong>可用任意“可访问性”修饰符来标记</strong>。而且<strong>可以在接口中定义</strong>。</p>
<p>每个属性都有名称和类型(类型不能为void)。属性不能重载，即不能定义名称相同、类型不同的两个属性。</p>
<p>get访问器对应的方法仅在定义了get访问器方法的时候生成。set同理。</p>
<p>属性与字段的区别：</p>
<ul>
<li>属性方法可能抛出异常；字段访问永远不会。</li>
<li>属性不能作为out或ref参数传给方法；字段可以。</li>
<li>属性方法可能花费较长的时间执行；字段总是立即完成。</li>
<li>连续多次调用，属性可能返回不同的值；字段则每次都相同。</li>
<li>属性可造成副作用(会造成对象的改变等)；字段不会。</li>
<li>属性可能需要额外的额内存；字段不会。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> String m_Name;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> String Name {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">get</span> { <span style="color:#66d9ef">return</span> m_Name; }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">set</span> { m_Name = <span style="color:#66d9ef">value</span>; } <span style="color:#75715e">// 关键字value总是代表新值</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// C#编译器编译后等同于以下代码</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> String m_Name;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> String get_Name() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> m_Name;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> set_Name() {
</span></span><span style="display:flex;"><span>    m_Name = <span style="color:#66d9ef">value</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="自动实现属性aip">自动实现属性(AIP)</h5>
<p>C#自动生成对应的get，set方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> String Name { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; } <span style="color:#75715e">// 自动实现属性</span>
</span></span></code></pre></div><p>不建议使用AIP的原因：</p>
<ul>
<li>没有办法简单的初始化AIP字段。必须在构造函数中初始化。</li>
<li>AIP字段名称由编译器决定，每次重新编译可能会改变这个名称。所以<strong>不支持序列化</strong>。</li>
<li>调试不能在get，set上加断点。</li>
</ul>
<h4 id="有参属性">有参属性</h4>
<p>get访问器接受一个或多个参数，set访问器接受两个或多个参数。</p>
<p>C#使用数组风格的语法来公开有参属性(索引器)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">sealed</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BitArray</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Byte[] <span style="color:#ae81ff">_</span>byteArray;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> <span style="color:#ae81ff">_</span>numBits;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> BitArray(<span style="color:#66d9ef">int</span> numBits) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (numBits &lt;= <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">throw</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">_</span>numBits = numBits;
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">_</span>byteArray = <span style="color:#66d9ef">new</span> Byte[(numBits + <span style="color:#ae81ff">7</span>) / <span style="color:#ae81ff">8</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 有参属性</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Boolean <span style="color:#66d9ef">this</span>[<span style="color:#66d9ef">int</span> pos] {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 索引器的get访问器方法</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">get</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (pos &lt; <span style="color:#ae81ff">0</span> || pos &gt;= <span style="color:#ae81ff">_</span>numBits) <span style="color:#66d9ef">throw</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> (<span style="color:#ae81ff">_</span>byteArray[pos / <span style="color:#ae81ff">8</span>] &amp; (<span style="color:#ae81ff">1</span> &lt;&lt; (pos % <span style="color:#ae81ff">8</span>))) != <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 索引器的set访问器方法</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">set</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (pos &lt; <span style="color:#ae81ff">0</span> || pos &gt;= <span style="color:#ae81ff">_</span>numBits) <span style="color:#66d9ef">throw</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">value</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 将索引位置设置为true</span>
</span></span><span style="display:flex;"><span>                <span style="color:#ae81ff">_</span>byteArray[pos / <span style="color:#ae81ff">8</span>] = (Byte) (<span style="color:#ae81ff">_</span>byteArray[pos / <span style="color:#ae81ff">8</span>] | (<span style="color:#ae81ff">1</span> &lt;&lt; (pos % <span style="color:#ae81ff">8</span>)));
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 将索引位置设置为false</span>
</span></span><span style="display:flex;"><span>                <span style="color:#ae81ff">_</span>byteArray[pos / <span style="color:#ae81ff">8</span>] = (Byte) (<span style="color:#ae81ff">_</span>byteArray[pos / <span style="color:#ae81ff">8</span>] &amp; ~(<span style="color:#ae81ff">1</span> &lt;&lt; (pos % <span style="color:#ae81ff">8</span>)));
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>注意：</p>
<ul>
<li>C#不支持定义静态索引器属性。CLR支持。</li>
<li>C#允许一个类型定义多个索引器，只要索引器的参数集不同。</li>
<li>C#将索引器看成对[]操作符的重载。</li>
</ul>
</blockquote>
<h4 id="属性访问器的性能">属性访问器的性能</h4>
<p>对于简单的get和set访问器，JIT编译器会将代码内联(inline)。使之基本没有性能损失。代价就是使编译好的方法变的更大。缺点在上方“属性与字段的区别”中有所列出。</p>
<blockquote>
<p>注意：JIT编译器在调试模式不会内联属性方法，因为会变的难以调试。</p>
</blockquote>
<h3 id="事件">事件</h3>
<p>定义了事件成员的类型允许类型(或类型的实例)通知其他对象发生了特定的事情。</p>
<p>CLR事件模型以<strong>委托</strong>为基础。委托是调用回调方法的一种类型安全的方式。</p>
<p>事件成员使用C#关键字event定义。每个事件成员都要指定以下内容：</p>
<ul>
<li>可访问性标识符(几乎是public)。</li>
<li>委托类型，指出要调用的方法的原型。</li>
<li>名称。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">// 定义一个类型来容纳所有应发送给事件通知者的附加信息</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TestEventArgs</span> : EventArgs {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> <span style="color:#66d9ef">string</span> <span style="color:#ae81ff">_</span>message;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> TestEventArgs(<span style="color:#66d9ef">string</span> message) {
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">_</span>message = message;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Message { <span style="color:#66d9ef">get</span> { <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">_</span>message; } }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TestEventManager</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 定义事件成员</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 泛型System.EventHandler委托类型的定义为：</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// public delegate void EventHandler&lt;TEventArgs&gt;(Object sender, TEventArgs e);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 则方法的原型必须为以下格式：</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// void MethodName(Object sender, TestEventArgs e);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">event</span> EventHandler&lt;TestEventArgs&gt; TestEvent;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 负责引发事件来通知登记的对象。</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> OnTestEvent(TestEvnetARgs e) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 出于线程安全的考虑，将委托字段的引用复制到一个临时变量中。避免在通过!=null的判断后被置空。</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Volatile.Read来保证让编辑器复制值，关闭编辑器的优化操作。</span>
</span></span><span style="display:flex;"><span>        EventHandler&lt;TestEventArgs&gt; temp = Volatile.Read(<span style="color:#66d9ef">ref</span> TestEvent);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (temp != <span style="color:#66d9ef">null</span>) temp(<span style="color:#66d9ef">this</span>, e);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 真正外部调用发送消息的方法</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> SendMessage(<span style="color:#66d9ef">string</span> message) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 构造一个对象来容纳数据</span>
</span></span><span style="display:flex;"><span>        TestEventArgs e = <span style="color:#66d9ef">new</span> TestEventArgs(message);
</span></span><span style="display:flex;"><span>        OnTestEvent(e);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="event在c编译器编译时转换的代码为">event在C#编译器编译时转换的代码为：</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">// 一个被初始化为null的私有委托字段</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> EventHandler&lt;TestEventArgs&gt; TestEvent = <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 一个公共add_xxx方法。允许方法登记对事件的关注</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> add_TestEvent(EventHandler&lt;TestEventArgs&gt; <span style="color:#66d9ef">value</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 通过循环和对CompareExchange的调用，可以以一种线程安全的方式向事件添加委托</span>
</span></span><span style="display:flex;"><span>    EventHandler&lt;TestEventArgs&gt; prevHandler;
</span></span><span style="display:flex;"><span>    EventHandler&lt;TestEventArgs&gt; newTestEvent = <span style="color:#66d9ef">this</span>.TestEvent;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>        prevHandler = newTestEvent;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将委托实例添加到委托列表中，返回新的列表头(地址)</span>
</span></span><span style="display:flex;"><span>        EventHandler&lt;TestEventArgs&gt; newHandler = (EventHandler&lt;TestEventArgs&gt;) Delegate.Combine(prevHandler, <span style="color:#66d9ef">value</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将这个地址存回字段</span>
</span></span><span style="display:flex;"><span>        newTestEvent = Interlocked.CompareExchange&lt;EventHandler&lt;TestEventArgs&gt;&gt;(<span style="color:#66d9ef">ref</span> <span style="color:#66d9ef">this</span>.TestEvent, newHandler, prevHandler);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">while</span> (newTestEvent != prevHandler);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 一个公共remove_xxx方法。允许方法注销对事件的关注</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> add_TestEvent(EventHandler&lt;TestEventArgs&gt; <span style="color:#66d9ef">value</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 通过循环和对CompareExchange的调用，可以以一种线程安全的方式向事件移除委托</span>
</span></span><span style="display:flex;"><span>    EventHandler&lt;TestEventArgs&gt; prevHandler;
</span></span><span style="display:flex;"><span>    EventHandler&lt;TestEventArgs&gt; newTestEvent = <span style="color:#66d9ef">this</span>.TestEvent;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>        prevHandler = newTestEvent;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将委托实例从委托列表中删除，返回新的列表头(地址)</span>
</span></span><span style="display:flex;"><span>        EventHandler&lt;TestEventArgs&gt; newHandler = (EventHandler&lt;TestEventArgs&gt;) Delegate.Remove(prevHandler, <span style="color:#66d9ef">value</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将这个地址存回字段</span>
</span></span><span style="display:flex;"><span>        newTestEvent = Interlocked.CompareExchange&lt;EventHandler&lt;TestEventArgs&gt;&gt;(<span style="color:#66d9ef">ref</span> <span style="color:#66d9ef">this</span>.TestEvent, newHandler, prevHandler);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">while</span> (newTestEvent != prevHandler);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>注意：即时事件字段定义为public，委托字段本身也是private。</p>
</blockquote>
<h4 id="登记并监听事件">登记并监听事件</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Fax</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 登记</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Fax(TestEventManager tem) {
</span></span><span style="display:flex;"><span>        tem.TestEvent += FaxMsg;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 注销登记</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Unregister(TestEventManager tem) {
</span></span><span style="display:flex;"><span>        tem.TestEvent -= FaxMsg;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 消息接收</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> FaxMsg(Object sender, TestEventArgs e) {
</span></span><span style="display:flex;"><span>        Console.WriteLine(<span style="color:#e6db74">&#34;message: &#34;</span> + e.Message);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>注意：对象只要登记了一个方法，就不能被垃圾回收。</p>
</blockquote>
 </div>
    <footer class="post-footer">

  <div class="post-footer-data">
            
<div class="tags">
  
    
      <div class="tag">
        <a href="https://sooda.net.cn/tags/clr-via-c">#《CLR via C#》</a>
      </div>
    
  
</div>

    <div class="date"> 2022-07-27 </div>
    
    <hr>
            
<div class="categories">
  
  Published in:
    
      <div class="category">
        <a href="https://sooda.net.cn/categories/%E9%98%85%E8%AF%BB%E6%8F%90%E7%82%BC">阅读提炼</a>
      </div>
    
  
</div>

            
<div class="series">
  
</div>

    
  </div>
</footer>


  
  



</article>

  <footer>

  <div class="social-links-footer">

  

  
  <a href="https://github.com/yLong765" target="_blank"><div class="social-link">GitHub</div></a>
  

  

  

  

  

</div>


  <div class="copyright"> Copyright © 2022, All Rights Reserved. </div>

  

  </footer>

</div> 

</body>
</html>


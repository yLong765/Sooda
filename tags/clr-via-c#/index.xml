<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>《CLR via C#》 on Sooda</title>
    <link>https://sooda.net.cn/tags/clr-via-c#/</link>
    <description>Recent content in 《CLR via C#》 on Sooda</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language>
    <copyright>Copyright © 2022, All Rights Reserved.</copyright>
    <lastBuildDate>Wed, 27 Jul 2022 15:20:36 +0800</lastBuildDate><atom:link href="https://sooda.net.cn/tags/clr-via-c#/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Class成员</title>
      <link>https://sooda.net.cn/post/clrviacsharp-class%E6%88%90%E5%91%98/</link>
      <pubDate>Wed, 27 Jul 2022 15:20:36 +0800</pubDate>
      
      <guid>https://sooda.net.cn/post/clrviacsharp-class%E6%88%90%E5%91%98/</guid>
      <description>类型成员基础 常量：数据恒定不变的符号。 字段：只读或可读/可写的数据值。 实例构造器：将新对象的实例字段初始化的特殊方法 类型构造器：将类型的静态字段初始化的特殊方法。 方法：更改或查询类型或对象状态的函数。作用于类型成为静态方法，作用于对象为实例方法。 操作符重载：实际是方法，定义了当操作符作用于对象时，应该如何操作对象。 转换操作符：定义如何隐式或显式将对象从一种类型转型为另一种类型的方法。 属性：设置或查询类型或对象的逻辑状态。作用于类型为静态属性，作用域对象为实例属性。 事件：静态事件允许类型向一个或多个静态或实例方法发送通知。实例事件允许对象向一个或多个静态或实例方法发送通知。 类型：可以定义其他嵌套类型。 常量 定义常量符号时，值必须能在编译时确定。编译器将常量值保存到程序集元数据中。意味着只能定义编译器可识别的基元类型常量。非基元类型的常量变量只能为null。
编译器会在定义常量的程序集元数据中查找该符号，提取常量值并嵌入IL代码中。所以运行时没有任何额外内存分配，但是不能取常量地址或引用传递常量。
C#不允许常量设置为static，因为常量总隐式设置为static。
如果希望在运行时从一个程序集中提取另一个程序集中的值，那么不应该使用常量，而应该使用readonly字段。
字段 字段是一种数据成员，容纳了一个值类型的实例或对一个引用类型的引用。
CLR支持类型(静态)字段和实例(非静态)字段。类型字段所需的动态内存是在类型对象中分配的，而类型对象是在类型加载到一个AppDomain时创建的。类型加载到AppDmain的时机又是在引用该类型的任何方法首次进行JIT编译的时候。实例字段容纳字段数据所需的动态内存是在构造类型的实例时分配的。
字段修饰符 CLR术语 C#术语 说明 Static static 类型(静态)字段 Instance (默认) 实例(非静态)字段 InitOnly readonly 只能有一个构造方法中的代码写入(但可利用反射修改readonly字段) Volatile volatile 编译器、CLR和硬件不会对访问这种字段的代码执行“线程不安全”的优化措施 注意：当某个字段时引用类型，并且该字段呗标记为readonly时，不可改变的是引用，而非字段引用的对象。
方法 实例构造器(引用类型) 实例构造器是初始化类型的实例的特殊方法。构造器方法在“方法定义元数据表”中始终叫做.ctor。创建引用类型的实例时，首先为实例的数据字段分配内存，然后把内存部分归零(保证没有被构造器显式赋值的所有字段都为0或null值)，接着初始化对象的附加字段(类型对象指针和同步索引块)，最后调用类型的实例构造器来设置对象的初始状态。
注意事项 实例构造器永远不能被继承。所以不能使用:virtual，new，override，sealed，abstract修饰符。 如果没有显式定义构造器，C#编译器则会默认定义一个(无参)构造器。这个构造器只是简单的调用了基类的构造器 public class A {} //等价于： public class A { public A() : base() {} } 如果类的修饰符为abstract，则编译器生成的默认构造器的可访问性就为protected。否则为public。 如果类的修饰符为static，则编译器不会生成默认构造器。 为了使代码“可验证”，类的实例构造器在访问从基类继承的任何字段之前，必须先调动基类的构造器。如果派生类的构造器没有显式调用一个基类构造器，C#编译器会自动生成对默认的基类构造器的调用。 极少数可以在不调用实例构造器的前提下创建类型的实例。比如Object的MemberwiseClone方法、或反序列化时。 不要在构造函数中调用虚方法。 C#编译器以“内联”(嵌入)方式初始化实例字段。在每个构造器方法开始的位置，包含类字段中直接赋值的代码。在其后会插入对基类构造器的调用。然后再插入构造函数的代码。
class B { } class A { public int a = 1; public int b = 3; public A() { b = 2; } } // C#编译器编译后的代码为 class A : B { public int a; public int b; public A() { a = 1; b = 3; // 调用父类构造器 b = 2; // b会被重复赋值 } } 优化：在声明字段是就赋值会导致再每个构造器中都会加入初始化代码。可以不在声明字段时赋值。用一个构造函数初始化，并在其他构造函数中调用那个构造函数。</description>
    </item>
    
    <item>
      <title>基元类型、引用类型和值类型</title>
      <link>https://sooda.net.cn/post/clrviacsharp-%E5%9F%BA%E5%85%83%E5%BC%95%E7%94%A8%E5%80%BC%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Tue, 12 Jul 2022 17:49:41 +0800</pubDate>
      
      <guid>https://sooda.net.cn/post/clrviacsharp-%E5%9F%BA%E5%85%83%E5%BC%95%E7%94%A8%E5%80%BC%E7%B1%BB%E5%9E%8B/</guid>
      <description>Type基础 C#中有三种类型分别是基元类型、引用类型和值类型
基元类型 编辑器直接支持的数据类型称为基元类型(primitive type)。基元类型直接映射到Framework类库(FCL)中存在的类型。
C#基元类型 FCL类型 符合公共语言规范(CLS) 说明 sbyte System.SByte 否 有符号8位 byte System.Byte 是 无符号8位 short System.Int16 是 有符号16位 ushort System.UInt16 否 无符号16位 int System.Int32 是 有符号32位 uint System.UInt32 否 无符号32位 long System.Int64 是 有符号64位 ulong System.UInt64 否 无符号64位 char System.Char 是 16位Unicode字符 float System.Single 是 IEEE 32位浮点值 double System.Double 是 IEEE 64位浮点值 bool System.Boolean 是 true/false decimal System.Decimal 是 128位高精度浮点值，常用于不容许误差的金融计算 string System.String 是 字符数组 object System.Object 是 所有类型的基类 dynamic System.</description>
    </item>
    
    <item>
      <title>C# class及成员基础</title>
      <link>https://sooda.net.cn/post/clrviacsharp-class/</link>
      <pubDate>Tue, 28 Jun 2022 17:09:01 +0800</pubDate>
      
      <guid>https://sooda.net.cn/post/clrviacsharp-class/</guid>
      <description>class System.Object “运行时”所有的类型最终都从System.Object类型派生。
// 隐式派生自Object class A {} // 显式派生自Object class A : System.Object {} System.Object的public方法
Equals：比较函数 GetHashCode：对象哈希值 ToString：转换成String类型对象 GetType：返回对象的类型 System.Object的protected方法
MemberwiseClone：创建类型的新实例，并将新对象的实例字段设置与this对象的实例字段完全一致。返回对新实例的引用 Finalize：垃圾回收阶段实际清理之前会调用此方法。 new操作符都做了什么工作 A a = new A(&amp;#34;123&amp;#34;); 上面的代码中new操作符所作的事情：
计算类型机器所有基类型(一直到System.Object)中定义的所有实例字段所需要的字节数。并加上每个对象都需要额外开销的类型对象指针(type object pointer)和同步块索引(sync block index) 。 从托管堆中分配1步骤中所计算的类型的字节数，从而分配对象的内存，分配的所有字节都设置为零(0)。 初始化对象的类型对象指针和同步块索引成员。 调用类型的实例构造器，传递在new调用中指定的实参。编译器会在构造函数(.ctor)中自动生成代码调用基类构造器 。最终都会调用System.Object的构造函数，但它什么都不做，单纯的返回。 返回指向新建对象的一个引用(或指针) 类型转换 CLR允许将对象转换为它的(实际)类型或者它的任何基类型。然而，将对象转换为派生类时，因可能转换失败，所以要求显示转换。
graph LR; A(&amp;#34;类型&amp;#34;)--隐式转换--&amp;gt;B(&amp;#34;基类&amp;#34;); A(&amp;#34;类型&amp;#34;)--显式转换--&amp;gt;C(&amp;#34;派生类&amp;#34;); is 和 as is操作符用于检查是否兼容于指定类型，如果对象引用null则总是返回false
Object o = new Object(); o is Object; // 返回true o is A; // 返回false as操作符用于检查是否兼容于指定类型，并进行转换。如果兼容则返回对于类型，不兼容则返回null。(判断null比检查是否兼容于指定类型快)
A a = o as A; if (a !</description>
    </item>
    
    <item>
      <title>CLR基础</title>
      <link>https://sooda.net.cn/post/clrviacsharp-clr%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Thu, 16 Jun 2022 11:16:04 +0800</pubDate>
      
      <guid>https://sooda.net.cn/post/clrviacsharp-clr%E5%9F%BA%E7%A1%80/</guid>
      <description>CLR的执行模型 公共语言运行时(Common Language Runtime, CLR)是一个可由多种编程语言使用的“运行时”。CLR的核心功能(比如内存管理、程序集加载、安全性、异常处理和线程同步)可由面向CLR的所有语言使用。
不同编程语言的意义？可将编译器视为语法检查器和“正确代码”分析器。它们检查代码，确定写的一切都有意义，并输出对其意图进行描述的代码。但是无论任何用哪个编译器，最终编译的结果都是托管模块(managed module)。托管模块是标准的32位Microsoft Windows可移植执行(Portable Executable, PE32)或64位(PE32+)文件。
graph TD; A(&amp;#34;C#源代码文件&amp;#34;)--&amp;gt;B(&amp;#34;C#编译器&amp;#34;)--&amp;gt;F(&amp;#34;托管模块(IL和元数据)&amp;#34;); C(&amp;#34;Basic源代码文件&amp;#34;)--&amp;gt;D(&amp;#34;Basic编译器&amp;#34;)--&amp;gt;F; E(&amp;#34;IL源代码文件&amp;#34;)--&amp;gt;G(&amp;#34;IL汇编器&amp;#34;)--&amp;gt;F; 高级语言(例如C#、F#等)通常只公开的CLR全部功能的一个子集。然而，IL汇编语言允许开发人员访问CLR的全部功能。
托管模块的组成部分 PE32或PE32+头部：标准Windows PE文件头，类似于“公共对象文件格式”(Common Oject File Format, COFF)。 CLR头部：包含使这个模块成为托管模块的信息(可由CLR和一些实用程序进行解释)。包含要求的CLR版本，一些标志(flag)，托管模块入口方法(Main方法)的MethodDef元数据token以及模块的元数据、资源、强名称、一些标志及其他不太重要的数据项的位置/大小。 元数据：每个托管模块都包含元数据表。主要由两种表：一种描述源代码中定义的类型和成员，另一种描述源代码引用的类型和成员。 用途： 避免编译时对原生C/C++头和库文件的需求，因为在实现类型或成员的IL代码文件中，已包含有关引用类型或成员的全部信息。编译器直接从托管模块读取元数据。 “智能感知”(IntelliSense)技术会解析元数据，告诉你一个类型提供了哪些方法、属性、事件和字段。对于方法，还能告诉其参数。 CLR的代码验证过程使用元数据确保代码只执行“类型安全”的操作。 允许将对象的字段序列化和反序列化。 允许垃圾回收器跟踪对象生存期。 IL(中间语言)代码：编译器编译源代码时生成的代码。在运行时，CLR用本机代码编译器(native code compolers)将IL编译成面向本机特定CPU架构的指令代码。 IL指令是一种基于栈的指令集（跟Lua一样）。操作压入栈，并从让结果从栈弹出。 IL指令还是无类型(typeless)的。 将托管模块组合成程序集 程序集(assembly) 是一个或多个模块或资源文件的逻辑性分组。程序集是重用、安全性以及版本控制的最小单元。CLR实际与程序集一起工作，程序集相当于它的“组件”。
清单(manifest) 是元数据表的集合。这些表描述构成程序集的文件、程序集中的文件所实现的public类型以及与程序集关联的资源或数据文件。
程序集的自描述(self-describing) 利用程序集模块中包含的引用程序集有关的信息(版本号)，CLR能判断为了执行程序集中的代码，程序集的直接依赖对象(immediate dependency)。
托管程序集总是利用Windows的数据执行保护(Data Execution Prevention, DEP)和地址空间布局随机化(Address Space Layout Randomization, ASLR)来增强系统安全性。
如果只有一个托管模块而且无资源(或数据)生成的程序集就是托管模块本身，生成无需额步骤。但如果希望将一组文件合并到程序集中，就必须用AL(程序集连接器)等工具生成。
graph LR; A(&amp;#34;托管模块(IL和元数据)【可多个】&amp;#34;)--&amp;gt;P(&amp;#34;将多个托管模块和资源合并成程序集的工具&amp;lt;br/&amp;gt;对应语言的编译器(例：C#为CSC.exe)&amp;lt;br/&amp;gt;程序集链接器(AL.exe)&amp;#34;) C(&amp;#34;资源文件(.jpeg,.gif,.html等)【可多个】&amp;#34;)--&amp;gt;P P--&amp;gt;L(&amp;#34;程序集&amp;lt;br/&amp;gt;清单(描述程序集中的文件集)&amp;lt;br/&amp;gt;托管模块(IL和元数据)【可多个】&amp;lt;br/&amp;gt;资源文件【可多个】&amp;#34;) 程序集的执行 分析以下程序的执行
static void Main() { Console.WriteLine(&amp;#34;Hello World!&amp;#34;); Console.WriteLine(&amp;#34;Goodbye!&amp;#34;); } 在Main方法执行之前，CLR会检测出Main方法的代码引用的所有类型(本例为Console)。并分配一个内部数据结构来管理对引用类型的访问。内部数据结构中对类型定义的每个方法都有一个对应的记录项。每个记录项都含有一个地址，根据此地址即可找到方法的实现。对这个结构初始化时，CLR将每个记录项的指针都指向包含在CLR内部的一个未编档函数(本书定义为JITCompiler)。 第一次执行Console.WriteLine方法时，JITCompiler函数会被调用。它负责将方法的IL代码编译成本机CPU指令。由于IL是“即时”(just in time)编译的，所有通常将CLR的这个组件叫做JIT编译器。JITCompiler函数的执行方式如下： 在负责实现类型(Console)的程序集的元数据中查找被调用的方法(WriteLine)。 从元数据中获取该方法的IL代码。并验证 动态分配内存块。 将IL代码编译成本机CPU指令然后将本机代码存储到步骤3分配的内存中。 在Type表(Main函数指向Console.</description>
    </item>
    
  </channel>
</rss>

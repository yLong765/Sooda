<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>《CLR via C#》 on Sooda</title>
    <link>https://sooda.net.cn/tags/clr-via-c#/</link>
    <description>Recent content in 《CLR via C#》 on Sooda</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language>
    <copyright>Copyright © 2022, All Rights Reserved.</copyright>
    <lastBuildDate>Thu, 16 Jun 2022 11:16:04 +0800</lastBuildDate><atom:link href="https://sooda.net.cn/tags/clr-via-c#/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CLR基础</title>
      <link>https://sooda.net.cn/post/clr-via-csharp/</link>
      <pubDate>Thu, 16 Jun 2022 11:16:04 +0800</pubDate>
      
      <guid>https://sooda.net.cn/post/clr-via-csharp/</guid>
      <description>CLR的执行模型 公共语言运行时(Common Language Runtime, CLR)是一个可由多种编程语言使用的“运行时”。CLR的核心功能(比如内存管理、程序集加载、安全性、异常处理和线程同步)可由面向CLR的所有语言使用。
不同编程语言的意义？可将编译器视为语法检查器和“正确代码”分析器。它们检查代码，确定写的一切都有意义，并输出对其意图进行描述的代码。但是无论任何用哪个编译器，最终编译的结果都是托管模块(managed module)。托管模块是标准的32位Microsoft Windows可移植执行(Portable Executable, PE32)或64位(PE32+)文件。
graph TD; A(&amp;#34;C#源代码文件&amp;#34;)--&amp;gt;B(&amp;#34;C#编译器&amp;#34;)--&amp;gt;F(&amp;#34;托管模块(IL和元数据)&amp;#34;); C(&amp;#34;Basic源代码文件&amp;#34;)--&amp;gt;D(&amp;#34;Basic编译器&amp;#34;)--&amp;gt;F; E(&amp;#34;IL源代码文件&amp;#34;)--&amp;gt;G(&amp;#34;IL汇编器&amp;#34;)--&amp;gt;F; 高级语言(例如C#、F#等)通常只公开的CLR全部功能的一个子集。然而，IL汇编语言允许开发人员访问CLR的全部功能。
托管模块的组成部分 PE32或PE32+头部：标准Windows PE文件头，类似于“公共对象文件格式”(Common Oject File Format, COFF)。 CLR头部：包含使这个模块成为托管模块的信息(可由CLR和一些实用程序进行解释)。包含要求的CLR版本，一些标志(flag)，托管模块入口方法(Main方法)的MethodDef元数据token以及模块的元数据、资源、强名称、一些标志及其他不太重要的数据项的位置/大小。 元数据：每个托管模块都包含元数据表。主要由两种表：一种描述源代码中定义的类型和成员，另一种描述源代码引用的类型和成员。 用途： 避免编译时对原生C/C++头和库文件的需求，因为在实现类型或成员的IL代码文件中，已包含有关引用类型或成员的全部信息。编译器直接从托管模块读取元数据。 “智能感知”(IntelliSense)技术会解析元数据，告诉你一个类型提供了哪些方法、属性、事件和字段。对于方法，还能告诉其参数。 CLR的代码验证过程使用元数据确保代码只执行“类型安全”的操作。 允许将对象的字段序列化和反序列化。 允许垃圾回收器跟踪对象生存期。 IL(中间语言)代码：编译器编译源代码时生成的代码。在运行时，CLR用本机代码编译器(native code compolers)将IL编译成面向本机特定CPU架构的指令代码。 IL指令是一种基于栈的指令集（跟Lua一样）。操作压入栈，并从让结果从栈弹出。 IL指令还是无类型(typeless)的。 将托管模块组合成程序集 程序集(assembly) 是一个或多个模块或资源文件的逻辑性分组。程序集是重用、安全性以及版本控制的最小单元。CLR实际与程序集一起工作，程序集相当于它的“组件”。
清单(manifest) 是元数据表的集合。这些表描述构成程序集的文件、程序集中的文件所实现的public类型以及与程序集关联的资源或数据文件。
程序集的自描述(self-describing) 利用程序集模块中包含的引用程序集有关的信息(版本号)，CLR能判断为了执行程序集中的代码，程序集的直接依赖对象(immediate dependency)。
托管程序集总是利用Windows的数据执行保护(Data Execution Prevention, DEP)和地址空间布局随机化(Address Space Layout Randomization, ASLR)来增强系统安全性。
如果只有一个托管模块而且无资源(或数据)生成的程序集就是托管模块本身，生成无需额步骤。但如果希望将一组文件合并到程序集中，就必须用AL(程序集连接器)等工具生成。
graph LR; A(&amp;#34;托管模块(IL和元数据)【可多个】&amp;#34;)--&amp;gt;P(&amp;#34;将多个托管模块和资源合并成程序集的工具&amp;lt;br/&amp;gt;对应语言的编译器(例：C#为CSC.exe)&amp;lt;br/&amp;gt;程序集链接器(AL.exe)&amp;#34;) C(&amp;#34;资源文件(.jpeg,.gif,.html等)【可多个】&amp;#34;)--&amp;gt;P P--&amp;gt;L(&amp;#34;程序集&amp;lt;br/&amp;gt;清单(描述程序集中的文件集)&amp;lt;br/&amp;gt;托管模块(IL和元数据)【可多个】&amp;lt;br/&amp;gt;资源文件【可多个】&amp;#34;) 程序集的执行 分析以下程序的执行
static void Main() { Console.WriteLine(&amp;#34;Hello World!&amp;#34;); Console.WriteLine(&amp;#34;Goodbye!&amp;#34;); } 在Main方法执行之前，CLR会检测出Main方法的代码引用的所有类型(本例为Console)。并分配一个内部数据结构来管理对引用类型的访问。内部数据结构中对类型定义的每个方法都有一个对应的记录项。每个记录项都含有一个地址，根据此地址即可找到方法的实现。对这个结构初始化时，CLR将每个记录项的指针都指向包含在CLR内部的一个未编档函数(本书定义为JITCompiler)。 第一次执行Console.WriteLine方法时，JITCompiler函数会被调用。它负责将方法的IL代码编译成本机CPU指令。由于IL是“即时”(just in time)编译的，所有通常将CLR的这个组件叫做JIT编译器。JITCompiler函数的执行方式如下： 在负责实现类型(Console)的程序集的元数据中查找被调用的方法(WriteLine)。 从元数据中获取该方法的IL代码。并验证 动态分配内存块。 将IL代码编译成本机CPU指令然后将本机代码存储到步骤3分配的内存中。 在Type表(Main函数指向Console.</description>
    </item>
    
  </channel>
</rss>

<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sooda</title>
    <link>https://ylong765.github.io/Sooda/</link>
    <description>Recent content on Sooda</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language>
    <copyright>Copyright © 2022, All Rights Reserved.</copyright>
    <lastBuildDate>Thu, 16 Jun 2022 11:16:04 +0800</lastBuildDate><atom:link href="https://ylong765.github.io/Sooda/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>《CLR via C#》总结</title>
      <link>https://ylong765.github.io/Sooda/post/clr-via-csharp/</link>
      <pubDate>Thu, 16 Jun 2022 11:16:04 +0800</pubDate>
      
      <guid>https://ylong765.github.io/Sooda/post/clr-via-csharp/</guid>
      <description>CLR的执行模型 公共语言运行时(Common Language Runtime, CLR)是一个可由多种编程语言使用的“运行时”。CLR的核心功能(比如内存管理、程序集加载、安全性、异常处理和线程同步)可由面向CLR的所有语言使用。
不同编程语言的意义？ 可将编译器视为语法检查器和“正确代码”分析器。它们检查代码，确定写的一切都有意义，并输出对其意图进行描述的代码。
无论任何用哪个编译器，最终编译的结果都是托管模块(managed module)。托管模块是标准的32位Microsoft Windows可移植执行(Portable Executable, PE32)或64位(PE32+)文件
托管程序集总是利用Windows的数据执行保护(Data Execution Prevention, DEP)和地址空间布局随机化(Address Space Layout Randomization, ASLR)来增强系统安全性
托管模块的组成部分 说明 PE32或PE32+头 标准Windows PE文件头，类似于“公共对象文件格式”(Common Oject File Format, COFF)头。 CLR头 包含使这个模块成为托管模块的信息(可由CLR和一些实用程序进行解释)。 元数据 每个托管模块都包含元数据表。主要由两种表：一种描述源代码中定义的类型和成员，另一种描述源代码引用的类型和成员。 IL(中间语言)代码 编译器编译源代码时生成的代码。在运行时，CLR将IL编程成本机CPU指令 本机代码编译器(native code compilers)生成的是面向特定CPU架构的代码。
每个面向CLR的编译器生成的都是IL代码。IL有时候成为托管代码(managed code)，因为CLR管理它的执行。
除了IL，每个面向CLR的编译器还要在每个托管模块中生成完整的元数据(metadata)。
元数据的用途：
避免编译时对原生C/C++头和库文件的需求，因为在实现类型/成员的IL代码文件中，已包含有关引用类型/成员的全部信息。编译器直接从托管模块读取元数据。 “智能感知”(IntelliSense)技术会解析元数据，告诉你一个类型提供了哪些方法、属性、事件和字段。对于方法，还能告诉其参数 </description>
    </item>
    
    <item>
      <title>《游戏编程算法与技巧》人工智能篇</title>
      <link>https://ylong765.github.io/Sooda/post/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%AF%87/</link>
      <pubDate>Wed, 19 Jan 2022 21:58:45 +0800</pubDate>
      
      <guid>https://ylong765.github.io/Sooda/post/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%AF%87/</guid>
      <description>搜索空间的表示 最简单的寻路设计就是将图作为数据结构。图中包含多个节点，连接相邻的点组成边。图有多种表示方式，最简单的是邻接表
游戏世界用图表示的方式 游戏世界用图来表示，有多种方法，一种简单的方法就是将世界区分为一个个正方形的格子（或者六边形）。如在《文明》策略游戏中的沙盘地图。而在不规则的地图中要么使用路点要么使用导航网格。
寻路节点 光卡设计师在游戏世界中拜访AI可以到达的位置。这些点被解释为图中的节点（可手动和自动生成）
缺点：AI只能在节点和边缘的位置移动。会有很多不可移动的位置，AI显得比较生硬
导航网格 图上的节点实际上就是凸多边形。邻近节点就是简单的任意邻近凸多边形。意味着游戏世界区域可以通过少量的凸多边形表示。
凸多边形内部任意位置都是可走的。意味着AI有了大量的空间可以行动。可返回更自然的路径
启发式算法 游戏寻路的启发式算法有很多，启发式用公式$h(x)$表示，理想情况下启发式结果越接近真实越好。如果它的估算总是保证小于等于真实开销，那么这个启发式是可接受的。目前比较流行的启发式算法就是A*算法。不过还有贪婪最佳优先算法，Dijkstra算法等。这里只介绍A*算法
A*算法 除了启发式 $h(x)$ 需要考虑，A又考虑了路径开销$g(x)$，所以A的节点开销等式为： $$ f(x) = g(x) + h(x) $$
在当前节点搜索可到达的节点加入开放集合中，并从中选出开销最小的点放入关闭集合，如此往复。而$g(x)$的开销取决于父节点的$g(x)$的开销。这意味着父节点是可选的，$g(x)$的开销是可变得</description>
    </item>
    
    <item>
      <title>《游戏编程算法与技巧》摄像机篇</title>
      <link>https://ylong765.github.io/Sooda/post/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7%E6%91%84%E5%83%8F%E6%9C%BA%E7%AF%87/</link>
      <pubDate>Fri, 14 Jan 2022 21:58:45 +0800</pubDate>
      
      <guid>https://ylong765.github.io/Sooda/post/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7%E6%91%84%E5%83%8F%E6%9C%BA%E7%AF%87/</guid>
      <description>摄像机的基础属性 视场 观看世界的角度和广度，称为视场(FOV)。人双目并视大约能看到120°的视场，而剩余的视场在边缘能够发现运动，但不清晰
如果视场变的太大就会有鱼眼效果，屏幕边缘会弯曲，类似于广角镜头
高宽比 视口的宽度和高度的比率（如4:3、16:9等)
摄像机的跟随实现 基础跟随 跟随在某个对象后方，保持固定距离，固定的俯视角摄像机
// tPos: 目标位置 // tForward: 目标方向 // hDist: 水平跟随距离 // vDist: 垂直跟随距离 void BasucFollowCamera(GameObject target, float hDist, float vDist) { // 计算相机位置 Vector3 pos = target.position - target.forward * hDist + target.up * vDist; // 计算相机朝向 Vector3 cameraForward = tPos - pos; // 设置相机位置和朝向 //... } 弹性跟随相机 实现相机到相机目标位置的逐渐变化，可以理解为真实位置的相机和在基础跟随所要到达的理想位置中间有一个弹簧
class SpringCamera { float hDist, vDist; // 水平和垂直跟随距离 float springConstant; // 弹性常量：越高弹性越小 float dampConstant; // 阻尼常量：由弹性常量决定 Vector3 velocity, actualPosition; // 速度和摄像机真实位置 GameObject target; // 跟随目标 void init(GameObject _target, float _springConstant, float _hDist, float vDist) { target = _target; springConstant = _springConstant; hDist = _hDist; vDist = _vDist; // 计算阻尼常量 dampConstant = 2.</description>
    </item>
    
    <item>
      <title>《游戏编程算法与技巧》物理篇</title>
      <link>https://ylong765.github.io/Sooda/post/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7%E7%89%A9%E7%90%86%E7%AF%87/</link>
      <pubDate>Tue, 04 Jan 2022 21:58:45 +0800</pubDate>
      
      <guid>https://ylong765.github.io/Sooda/post/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7%E7%89%A9%E7%90%86%E7%AF%87/</guid>
      <description>平面 平面在游戏中倾向的数学定义：
$$ P \cdot \hat{n} + d = 0 $$
$P$是平面上任意一点，$\hat{n}$是平面法线，$d$是平面到原点的最小距离
// 平面的数据结构 struct Plane { Vector3 normal; float d; } 射线和线段 游戏中射线基本就是线段，因为基本不会让射线无限延伸下去。数学定义为：
$$ R(t) = R_0 + \vec{v}t $$
$R_0$是起点，$\vec{v}$是射线方向，$t$必须大于等于0。而在代码中的数据结构我们存两个点一个起点(startPoint)，一个终点(endPoint)。则$R_0$就是startPoint，$\vec{v}$就是endPoint-startPoint，而$t$的取值就为0~1了
struct RayCast { Vector3 startPoint Vector3 endPoint } 碰撞几何体 包围球 通过中心点和半径表示
class ShpereCollider { Vector3 center; float radius; } 轴对齐包围盒(AABB) 每条边都与x轴或y轴平行的矩形，只能随轴旋转，多用于2D
class AABB2D { Vector2 min Vector2 max } 朝向包围盒OBB 可以自由旋转的类AABB包围盒，较复杂
胶囊体 3D中为一个圆柱加上两个半圆，还可看作带半径的线段
struct Capsule2D { Vector2 startPoint; Vector2 endPoint; float radius; } 凸多边形 简称凸包。凸多边形比其他前几个方式效率低，但是更精准</description>
    </item>
    
    <item>
      <title>《游戏编程算法与技巧》输入和声音篇</title>
      <link>https://ylong765.github.io/Sooda/post/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7%E8%BE%93%E5%85%A5%E5%92%8C%E5%A3%B0%E9%9F%B3%E7%AF%87/</link>
      <pubDate>Fri, 24 Dec 2021 08:55:57 +0800</pubDate>
      
      <guid>https://ylong765.github.io/Sooda/post/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7%E8%BE%93%E5%85%A5%E5%92%8C%E5%A3%B0%E9%9F%B3%E7%AF%87/</guid>
      <description>游戏输入 可分为两种：数字与模拟
数字输入 只用两种状态：“按下”和“没有按”（例如键盘）
如何实现一直按着的判断？ 同时跟踪上一帧和这一帧的状态，根据这两个状态来判断
上一帧状态 本帧状态 结论 释放 释放 一直释放 释放 按下 刚刚按下 按下 释放 刚刚释放 按下 按下 一直按下 伪代码：
enum KeyState { StillReleased, JustPressed, JustReleased, StillPressed } lastState[256]; // 上一帧状态 currentState[256]; // 当前帧状态 // 每帧更新状态 void UpdateKeyboard() { lastState = currentState; currentState = GetKeyboardState(); // 获取当前状态 } // 通过keyCode获取KeyState KeyState GetKeyState(int keyCode) { if (lastState[keyCode]) if (currentState[keyCode]) return StillReleased; else return JustReleased; else if (currentState[keyCode]) return JustPressed; else return StillReleased; } 模拟输入 可返回某个数字的范围（如遥感）。但遥感的数值基本不会归零所以需要输入过滤，来消除偏差值。一般取遥感总值的10%为无效值。</description>
    </item>
    
    <item>
      <title>《游戏编程算法与技巧》渲染篇</title>
      <link>https://ylong765.github.io/Sooda/post/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7%E6%B8%B2%E6%9F%93%E7%AF%87/</link>
      <pubDate>Wed, 22 Dec 2021 15:57:24 +0800</pubDate>
      
      <guid>https://ylong765.github.io/Sooda/post/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7%E6%B8%B2%E6%9F%93%E7%AF%87/</guid>
      <description>闲话 近日读完了《游戏编程算法与技巧》这本书。更感觉是《游戏引擎架构》的缩略图。先阅读此书会对游戏开发有一个整体的认识与理解。适合需要了解游戏开发的初学者阅读
此书对于我也是梳理游戏开发知识点的概括好书。对于此书会在重点部分做提炼。
渲染基础 此部分只做简单的总结，网上已经有很多的好文章了。而此书作者也没有很详细的写这部分。毕竟这块要是讲细了够学一辈子了
推荐一些好文（有兴趣可以看看我写的软渲染）
闫令琪老师的GAMES101课程 韦易笑老师的mini3d项目 韦易笑老师的RenderHelp项目 Dmitry V. Sokolov老师的tinyrender项目 双缓冲技术解决渲染撕裂 CRT显示器时代，所谓场消隐期（VBLANK）：喷枪从右下角移动到左上角所花费的时间
渲染撕裂：显示器在绘制像素缓冲区中的内容时，游戏输出了新的渲染结果到像素缓冲区，导致渲染撕裂
双缓冲技术：解决屏幕撕裂，用两块像素缓冲区，游戏交替的在这两块缓冲区中绘制
垂直同步：让交换缓冲区的时机在场消隐期进行
三缓冲技术：利用3个缓冲区，让画面更加平滑，但增加输入延迟
画家算法 所有物体按照从后往前的顺序绘制。优点：绘制绝对正确（包括透明物体），缺点：overdraw高，效率慢
3D渲染 为什么用三角形表示面片？
仅用3顶点表示的最简单的多边形 三角形总在一个面上 任何3D对象都可以简单地用细分三角面表示 网格：多个三角面组成
软件光栅化 将3D模型正确渲染到2D颜色缓冲的算法
3D模型经过4个主要坐标系空间转到最终的2D颜色缓冲中
模型（局部）坐标系：相对于模型自身的坐标系（角色模型一般为两脚中间） 世界坐标系：所有对象都相对于世界原点偏移 视角（摄像机）坐标系：将世界坐标系的模型变换到相对于摄像机的位置上 投影坐标系：将3D场景平铺到2D平面上得到的坐标系 除了上面的坐标系外，还有一个特殊的坐标系，就是齐次坐标系
将4D坐标系应用在3D空间中，就被称为齐次坐标系。而第四个分量为w分量。如果w=0，则此齐次坐标是3D向量。而w=1，则表示此齐次坐标是3D的点
矩阵变换 将模型在各个坐标系中转换所用的矩阵，就是矩阵变换。
此处和之后所用的都为行向量。（OpenGL为列向量） 模型转世界坐标系 平移 将顶点移动一段距离，只作用在点上
$$ T(t_x,t_y,t_z) = \begin{bmatrix} 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \newline 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \newline 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \newline t_x &amp;amp; t_y &amp;amp; t_z &amp;amp; 1 \end{bmatrix} $$</description>
    </item>
    
    <item>
      <title>《Unity实战》总结</title>
      <link>https://ylong765.github.io/Sooda/post/unity%E5%AE%9E%E6%88%98/</link>
      <pubDate>Sun, 07 Nov 2021 22:05:19 +0800</pubDate>
      
      <guid>https://ylong765.github.io/Sooda/post/unity%E5%AE%9E%E6%88%98/</guid>
      <description>闲话 本文意加强对Unity的一些知识点的补充，所以基本以记录为主。
零散知识 Unity使用左手坐标系 所有场景对象都是类GameObject的实例。GameObject只是组件的容器 变量赋值数字后的f让计算机把这个变量作为浮点值处理，否则C#会把小数当成双精度值（C++也是一样） 本地坐标：对象有自己的原点，有三个轴，且坐标系跟着对象移动 全局（世界）坐标：与本地坐标的区别就是不移动 Cursor.lookState = CursorLockMode.Locked; // 光标锁定屏幕中心 Cursor.visible = false; // 隐藏光标 Unity的场景拥有所有此场景所有GameObject的引用，用Destroy来告诉引擎，将这个对象从Scene中移除 Shader中的Albedo是基础颜色的意思 用2D开启的新项目，Unity主要调整了2D Editor模式（将导入的图片设置为Sprite）和2D Scene视图 Unity中的导入设置Pixels-To-Units是像素与Unity原默认3D的一个单位的比例，默认是100:1（建议使用默认值，在1:1的状态下物理引擎不能正常工作） 像素完美（Pixel-perfect）：屏幕上的每一个像素对应图像中的一个像素（否则会让图像在缩放到屏幕大小时变的模糊） LoadScene：加载不同关卡时，当前关卡的所有内容（场景中所有对象和所有附件的脚本）都会从内存中清除，接着从新场景中加载所有需要的对象 修改Transform.position将会忽略碰撞检测（Unity的碰撞用的第三方整合的，所以理论来说Transform系统和物理系统是两个单独的系统，所以移动操作应只利用其中一种） Mathf.Approximately(float, float)：用于浮点数比较 Order in Layer设置：控制绘制前后顺序（同层Z轴控制前后） 平视显示（HUD，heads-up display）：使图形叠加在世界视图上 OnGUI：立即模式的GUI系统，每帧显式发送绘制指令。会在每帧渲染完3D场景后执行 保留模式（retained mode）：一次定义所有的视觉效果，系统知道会绘制什么，不需要重新声明 Canvas组件 创建Canvas组件时随带的EventSystem是用于UI交互的 Canvas中屏幕的一个像素对应的就是场景中的一个单位 Render Moad Screen Space-Overlay：将UI渲染为摄像机视图顶部的2D图形 Screen Space-Camera：将UI渲染在摄像机视图顶部，但UI元素可以旋转，得到透视效果 World Space：将画布对象放在场景中，就好像UI是3D场景的一部分 UI对象的锚点（anchor）：对象依附到画布或屏幕的点，决定计算对象位置所依赖的点 切割图像（sliced image，九宫格）：把图像切割成九份，各部分相互独立，分别缩放。从中间缩放图像边缘，可确保图像缩放为任何期望的尺寸，且边缘清晰 模型导入Model中Normals选项控制光线和阴影在模型上的显示 Import：使用定义在导入网格几何体中的法线 Calculate：让Unity自己计算每个多边形的法线 光照贴图（lightmapping）：将几何体的阴影烘焙到贴图图像中 Mesh Renderer中可控制是否投射阴影和是否接受阴影 位置向量乘于四元数，结果是基于旋转的偏移位置 Vector3.ClampMagnitude：限制对角线，使其延轴移动的速度一样（从原点画圆） Animator中的动画过度 Has Exit Time：迫使动画一直播放，而不是在变换发生时马上暂停 Interruption Source改为Current State说明变换自身能被打断 美术资源 网格对象：指的是3D对象（连线和形状）的几何结构 模型：通常包括对象的其他属性 材质：一组信息，定义了附加材质对象的表面属性（颜色，发光等—）。多个对象可共享一个材质。每个材质都有一个控制它的着色器（可认为每种材质都是着色器的一个实例） 动画：定义关联对象的运动信息。运动能独立于对象自身定义，所以可以混合-匹配的方式用于多个对象（必须为同一种骨骼） 粒子系统：用于生成和控制大量运动对象的规则机制。运动对象通常较小所以被称为粒子系统。但并不一定要小 粒子：粒子系统控制的独立对象。可以是任何网络对象，但对于大多数效果，粒子显示图片的方块 贴图：用于提高3D图形效果的2D图像 用于显示在3D模型的表面 法线贴图使表面产生凹凸 贴图文件格式类型 优缺点 PNG 通常用于万维网。无损压缩，带透明 JPG 通常用于万维网。有损压缩，无透明 GIF 通常用于万维网。有损压缩，无透明（损耗并不是压缩造成的，是图片转为八位时导致数据丢失） BMP windows上默认模式。无压缩，无透明 TGA 通常用于3D图形（不常用）。无损压缩或不压缩，带透明 TIFF 通常用于数字相片和出版。无损压缩或不压缩，无透明 PICT 旧Macs系统默认格式。有损压缩，无透明 PSD Photoshop原生文件。无压缩，有透明 图像的压缩方式和是否有透明通道这两个是比较重要的因素 有透明通道会更好 不压缩和无损压缩保证质量，有损压缩降低了品质，但减小了文件大小（具体取舍有 贴图的大小应为2的次幂（从4~2048字节） 天空盒：是一个包围摄像机的立方体。每个面都是天空图片的贴图 着色器：一种简短的程序，列出了绘制表面的指令 一些Unity自带的着色器： Additive着色器：将粒子颜色叠加到它背后的颜色上的着色器，使颜色更加明亮，而粒子的黑色部分不可见。 Multiply着色器：与Additive相反，使对象颜色更暗 3D模型：美术资源可直接拖入引擎，unity会将文件导出为FBX然后重新加载到Unity中。尽量避免直接拖入美术资源，应将模型先导出为FBX后再直接导入到Unity为好。避免后续的资源修复问题和共享资源复杂等问题 可导入模型自带材质 3D模型文件类型 优缺点 FBX 网格和动画 Collada(DAE) 网格和动画 OBJ 只有网格；文本格式 3DS 只有网格 DXF 只有网格 使用粒子系统创建效果 粒子系统时创建和控制大量移动对象的规则机制</description>
    </item>
    
    <item>
      <title>《游戏引擎架构》动画的基本构成</title>
      <link>https://ylong765.github.io/Sooda/post/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E5%8A%A8%E7%94%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9E%84%E6%88%90/</link>
      <pubDate>Sun, 07 Nov 2021 17:14:24 +0800</pubDate>
      
      <guid>https://ylong765.github.io/Sooda/post/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E5%8A%A8%E7%94%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9E%84%E6%88%90/</guid>
      <description>闲话 近日读完了《游戏引擎架构》这本书，以前感觉读不完，但是每天慢慢的磨完了。闲下来时间提炼一下其中自我觉得比较关键的部分。因本人是做Unity开发的，所以会把书中所讲部分结合Unity引擎来总结。闲话不多说开始吧
动画的基本构成 Unity的动画系统封装的已经非常好了，所以我们对其中的细节了解的少之又少。本文章着重在单个动画，骨骼，姿势，蒙皮的内存存储结构和应用方式
角色动画的类型 在Unity中比较常用的动画为蒙皮/骨骼动画（三维）和精灵动画（二维）
赛璐璐动画（精灵动画）：用一张细小的位图，叠在全屏的背景影响之上而不会扰乱背景。常用于二维游戏动画（Unity中的Sprite贴图） 动画纹理：面向摄像机的四边形，并用一连串的位图连续播放。现今用于远景活低分辨率的物体 刚性阶层动画：将角色通过部位进行拆分建模并以层级进行约束。但问题是在关节处会出现裂缝 每顶点动画：移动每个顶点以产生更自然的动作（蛮力技术，数据量非常大。通常用于老式的离线渲染） 变形目标动画：每顶点动画的变种，也是制作每个顶点的位置。但制作少量的固定极端姿势在运行时将其混合（线性插值混合）。通常用于面部动画 蒙皮/骨骼动画： 骨骼：隐藏的刚性关节层阶结构（树结构）所构成 皮肤：绑定于骨骼上的圆滑三角形网格，顶点会按权重绑定至多个关节。当关节移动时，蒙皮可以自然的拉伸 为什么选择蒙皮/骨骼动画？ 以更少的数据量来达到更好的效果。通过加入约束：相对大量的顶点只能跟随相对少量的骨骼关节移动。来压缩顶点动画
骨骼在内存中的表示 通常使用关节索引引用关节，子关节索引引用父关节。蒙皮三角形网格中，每个顶点索引引用其绑定关节
// 关节数据的信息 struct Joint { Matrix4x3 inv_bind_pose; // 绑定姿势（蒙皮网格顶点绑定至骨骼时，关节的位置，定向及缩放）的逆变换 const char* name; // 关节名字（字符串或32位字符串散列表标识符） U8 parent; // 父索引(0xFF代表根关节) }; struct Skeletion { U32 joint_count; // 关节数目 Joint* joint; // 关节数组 }; 姿势 把角色摆出一连串离散，静止的姿势，并以通常30或60个姿势每秒的速率显示，已产生动感。实际游戏会以相邻姿势进行插值
绑定姿势：又称为T姿势。因此姿势四肢远离身体，较容易把顶点绑定至关节
局部姿势 相对于父关节指定的，其仿射变换相对于父节点空间
关节姿势：数学上就是一个仿射变换。4x4仿射变换矩阵$P_j$，此矩阵由平移矢量$T_j$，3x3对角缩放矩阵$S_j$，及3x3旋转矩阵$R_j$构成
$$ p_j = \begin{bmatrix} S_jR_j &amp;amp; 0 \newline T_j &amp;amp; 1 \end{bmatrix} $$
整个骨骼的姿势：
$$ P^{skel} = { P_j } |_{j=0}^{N-1} $$</description>
    </item>
    
  </channel>
</rss>

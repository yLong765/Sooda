<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[判断点在多边形内部]]></title>
    <url>%2F2019%2F04%2F07%2F%E5%88%A4%E6%96%AD%E7%82%B9%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85%E9%83%A8%2F</url>
    <content type="text"><![CDATA[点在多边形内部的判断有很多种方法，性能最好也准确的算法应属射线法。 推荐Milo Yip大神的知乎上的回答 射线法思想射线法是由从点出发向一个方向发送射线，判断与边相交的次数，如果为奇数则为多边形的内部，如果为偶数则为外部。 首先是数据类，存储多边形的点和最大最小的XY，用来做快速判断1234567891011121314151617181920212223242526// 多边形点的数据存储class PolygonConfig&#123; public float maxX; public float maxY; public float minX; public float minY; public List&lt;Vector2&gt; points = new List&lt;Vector2&gt;(); public void SetMaxAndMinXY() &#123; if (points.Count &gt; 0) &#123; maxX = points[0].x; maxY = points[0].y; minX = points[0].x; minY = points[0].y; &#125; for (int i = 1; i &lt; points.Count; i++) &#123; maxX = Mathf.Max(maxX, points[i].x); maxY = Mathf.Max(maxY, points[i].y); &#125; &#125;&#125; 下面是判断的核心方法 首先是通过最大最小的XY来快速筛选点是否在四边形中 核心代码部分 这里我们做向上的射线（射线方向随意，这里我们向上做） 第一组判断(points[i].x &lt;= point.x &amp;&amp; points[j].x &gt; point.x) || (points[j].x &lt;= point.x &amp;&amp; points[i].x &gt; point.x) 这里主要的意思就是点的x坐标是否在多边形的一个边的x轴坐标内。(可理解成: p1.x &lt; p.x &lt; p2.x) 第二组判断(points[j].y - points[i].y) / (points[j].x - points[i].x) * (point.x - points[i].x) + points[i].y &gt; point.y 让我们分开来理解，首先是(points[j].y - points[i].y) / (points[j].x - points[i].x)是x轴差值和y轴差值的比值，(point.x - points[i].x)是点与边中一点的x轴差值，两者的相乘就确定了一个y，y值再加上那边中一点的y值，如果大于点的y则穿过，否则没穿过。 进过所有边的判断完成后，奇数为在中心，所以小技巧就是inPolygon的取反。1234567891011121314151617181920private bool IsPointInPolygon(PolygonConfig polygon, Vector2 point)&#123; // 构建矩形，进行快速筛选 if (point.x &gt; polygon.maxX || point.x &lt; polygon.minX || point.y &gt; polygon.maxY || point.y &lt; polygon.minY) &#123; return false; &#125; bool inPolygon = false; var points = polygon.points; for (int i = 0, j = points.Count - 1; i &lt; points.Count; j = i++) &#123; if (((points[i].x &lt;= point.x &amp;&amp; points[j].x &gt; point.x) || (points[j].x &lt;= point.x &amp;&amp; points[i].x &gt; point.x)) &amp;&amp; ((points[j].y - points[i].y) / (points[j].x - points[i].x) * (point.x - points[i].x) + points[i].y &gt; point.y)) &#123; inPolygon = !inPolygon; &#125; &#125; return inPolygon;&#125;]]></content>
      <tags>
        <tag>Point in Polygon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity-Framework]]></title>
    <url>%2F2018%2F11%2F23%2FUnity%20Framework%2F</url>
    <content type="text"><![CDATA[Unity 框架本文UI框架借鉴游客学院 本文章源码可在我的GitHub中找到 UI框架 UI框架简介本框架用的UGUI，比较难做出3D效果的界面，3D特效界面还是用NGUI好一些。SceneLogin、SceneMain、SceneTest是演示的三个界面。 框架流程Scene打开界面通过SceneMgr。SceneMgr会调用SceneBase中的OnInit。数据会传输到sceneDates不定长数组里。界面初始化会如下依次执行 InitDate()：必须设置UI皮肤（UI的prefab），界面没有生成前的初始化数据。 InitSkin()：会自动执行，创建UI实例。 InitViewDate()：界面生成完后，绑定界面UI的初始化。（如我想知道玩家输入的名字叫什么，可以绑定Text获取，注：Button已经被绑定完成不需要重写绑定）。 其他可重写函数 onClick(GameObject BtObject)：相应Button事件，通过传入的BtObject分辨每个Button。 SceneLogin.cs代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class SceneLogin : SceneBase &#123; private InputField playerName; private Text warnText; protected override void InitDate() &#123; //初始化皮肤 setSkinPath("UI/Scene/" + SceneType.SceneLogin.ToString()); &#125; protected override void InitViewDate() &#123; //绑定界面UI playerName = skin.transform.Find("loginBackground/playerName").GetComponent&lt;InputField&gt;(); warnText = skin.transform.Find("warnText").GetComponent&lt;Text&gt;(); &#125; protected override void onClick(GameObject BtObject) &#123; if (BtObject.name.Equals("BtGameStart")) &#123; string name = playerName.text; if (NameChick(name)) &#123; SceneMgr.Instance.Sequencer(SceneType.SceneMain, name); &#125; else &#123; warnText.text += "不符合规范"; warnText.gameObject.SetActive(true); &#125; &#125; &#125; private bool NameChick(string name) &#123; //正则表达式 if (name == null) return false; if (name.Equals("/0")) return false; if (name.Length &lt; 0 || name.Length &gt; 10) return false; return true; &#125;&#125; 更新 —- 17年04月01日加入消息机制框架。 更新 —- 17年12月23日加入对象池：使用固定的对象池重用对象，取代单独地分配和释放对象，以此来达到提升性能和优化内存使用的目的。 加入单例管理：MonoSingletonMgr和SingletonMgr。 更新 —- 18年8月28日重写MonoSingleton，修复Editor模式调用时产生多实例的问题，添加Create方法用于初始化。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Code:The Hidden Language of Computer Hardware and Software》阅读精粹]]></title>
    <url>%2F2018%2F10%2F20%2F%E3%80%8A%E7%BC%96%E7%A0%81-%E9%9A%90%E5%8C%BF%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%83%8C%E5%90%8E%E7%9A%84%E8%AF%AD%E8%A8%80%E3%80%8B%E9%98%85%E8%AF%BB%E7%B2%BE%E7%B2%B9%2F</url>
    <content type="text"><![CDATA[关于作者Charles Petzold 是Windows编程界的一位大师，1994年作为仅有的七人之一，被授予Windows Pioneer奖。其著作Programming Windows是尽人皆知的Win32 API编程经典，是学习Windows编程的必读之作。 此书作者采用的叙述方式奇特却又如此自然，他首先从历史的角度审视了计算机技术的发展脉络，继而自底向上地奖计算机体系结构方面的知识娓娓道来。（引自译者序—薛佟佟） 开始此书打算从每一章的角度提取重点作为记录。 01 至密亲友这一章介绍了编码的由来，和莫尔斯电码的发明，这里看似与计算机毫无关系，但是对于深入了解计算机软硬件内部结构以及隐匿在其背后的语言将大有裨益（背后的语言就为二进制，而二进制其实就是一种编码）。 编码：指一种又来在机器和人之间传递信息的方式，编码就是交流。 莫尔斯电码：一种表示26个字母的编码，如果利用手电筒传递信息，通过短闪和长闪来制作编码，而其最著名的就属SOS，SOS并不是一个缩写，而是一个易记得莫尔斯编码序列，即为短短短长长长短短短。 02 编码与组合就01中我们总结的莫尔斯编码，可以把点（短闪）视为0把划（长闪）视为1，总结为二进制我们会发现规律： 码子的数目 = 2^{“点”和“划”的数目}码子的数目 = 2^{编码的位数}用表格列出则为: 点划的数目 码子的数目 1 2^1 = 2 2 2^2 = 4 3 2^3 = 8 4 2^4 = 16 5 2^5 = 32 03 布莱叶盲文与二进制码布莱叶盲文中，每个在书写中用到的符号——具体来说就是字母、数字和标点符号——都被编码成了2*3的点码单元中的一个或者多个凸起的点。通常用数字1-6来进行编码。而每个点也可以有两种表示方式为：不凸起和凸起，所以一共可以表示 $ 2^6 = 64 $ 种编码组合 04 手电筒的剖析 电路就是一个环路 原子由三种粒子构成：中子(neutron)、质子(proton)和电子(electron) 导线越粗，阻抗越低。粗一些的导线可以使更多的电子顺畅的通过线路 欧姆定律： I = E / R 其中，I用来表示电路中的电流，E用来表示电压，R表示电阻。 如果导线电阻较低的话，它将会变热并且发光。这就是白炽灯发光的原理。 瓦特使功率(p)的计量单位，公式为：P = E * I 05 绕过拐角的通信 AWG(American Wire Gauge)美国线径标准，AWG越小，导线越粗，电阻越小 06 电报机和继电器继电器：当输入的电流触发了电磁铁，电磁铁把一个弹性金属条吸附下来，就像闭合了开关一样，使电流可以从接口输出。 07 我们的十个数字数学又称为“通用语言”，因为全世界几乎都是用1~9来描述数字的。罗马数字：M表示1000，D表示500，C表示100，L表示50，X表示10，V表示5，I表示1。罗马数字都是由这些字母所组成的。现如今的数字通用系统为阿拉伯数字，与其他数字系统最重要的区别为有“0”，从而支持了计数法，可以将25、205和250区分开来。0也简化了与位置无关的运算，尤其是乘法和除法。 08 十的代替品如果人类的手指不是十个的话，我们的计数方式可能会大不相同。而对于计算机来说最重要的发明就是二进制，而电线就可以表示二进制，比如有电流就为1，无电流就为0。同样电报继电器也是一样的道理。而bit也为表示二进制而发明。 09 二进制数bit被看做是组成信息块的基本单位。要把二进制看为一种表示信息的方式，而不是看待成数字。一个二位的二进制数可以表示四种信息，一个三为的二进制数可以表示8种信息。 10 逻辑与开关]]></content>
      <categories>
        <category>Read</category>
      </categories>
      <tags>
        <tag>Read</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性代数内在原理]]></title>
    <url>%2F2018%2F09%2F08%2F%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%86%85%E5%9C%A8%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[线性代数的内在原理最近为了学习图形学又学了一遍线代，感觉还是没有太理解透线代。无意间看到一个讲解线代的视频[3Blue1Brown的线代中文视频]，总结一下。 Base 基向量基向量可以是任意的向量，是可以自己设定的，如在二维空间中通常取的向量为x轴方向的单位向量和y轴方向的单位向量，我们记做： \hat i And \hat j每一个向量都可以用两个基向量来进行表示。如图： 这里我们发现一个有趣的问题，比如你在二维空间选取了方向相同或者相反的向量，则他能表示的向量只存在于一条直线上了（降维）。如果我们两个向量都取零向量，则为降维到一个点。 由上面的总结可知公式 \vec v = x\hat i + y\hat j = \begin{bmatrix} x\\y\\ \end{bmatrix}矩阵的相乘（几何空间意义为转换）把基向量展开我们得到公式： \begin{bmatrix} a&b\\c&d\\ \end{bmatrix} \begin{bmatrix} x\\y\\ \end{bmatrix} = x\begin{bmatrix} a\\c\\ \end{bmatrix} + y\begin{bmatrix} b\\d\\ \end{bmatrix} = \begin{bmatrix} ax + by\\cx + dy\\ \end{bmatrix}这里需要注意的是矩阵的读法是从右往左，即 M_1M_2 \neq M_2M_1 矩阵相乘上面列举了2x2的矩阵和2x1的矩阵相乘的算法，那么2x2与2x2的矩阵怎么运算呢 \begin{bmatrix} a&b\\c&d\\ \end{bmatrix} \begin{bmatrix} e&f\\g&h\\ \end{bmatrix} = ?分解为两个矩阵的相乘： \begin{bmatrix} a&b\\c&d\\ \end{bmatrix} \begin{bmatrix} e\\g\\ \end{bmatrix} = e\begin{bmatrix} a\\c\\ \end{bmatrix} + g\begin{bmatrix} b\\d\\ \end{bmatrix} = \begin{bmatrix} ae + bg\\ce + dg\\ \end{bmatrix}\begin{bmatrix} a&b\\c&d\\ \end{bmatrix} \begin{bmatrix} f\\h\\ \end{bmatrix} = f\begin{bmatrix} a\\c\\ \end{bmatrix} + h\begin{bmatrix} b\\d\\ \end{bmatrix} = \begin{bmatrix} af + bh\\cf + dh\\ \end{bmatrix}最后将其组合： ? = \begin{bmatrix} ae + bg&af + bh\\ce + dg&cf + dh\\ \end{bmatrix}]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>Linear algebra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo支持mathjax]]></title>
    <url>%2F2018%2F08%2F31%2Fhexo%E6%94%AF%E6%8C%81mathjax%2F</url>
    <content type="text"><![CDATA[hexo支持mathjax技术博客有时避免不了一些数学公式，利用Hexo建立博客后，最开始利用Google的公式库，但是得请求Google的网址，有时会被墙，所以不得不转战方向。让Hexo自己支持mathjax必然是一个省心的过程。然而事实并不省心。如果要建立一个支持数学公式的基于Hexo框架的博客，你得符合以下要求： 博客：Hexo，博客的搭建可以看我之前的文章 支持mathjax的markdown渲染器：hexo-renderer-kramed 支持mathjax的Theme：NexT：(NexT使用文档，之前用的Archar，不过不支持mathjax) markdown编辑器：Typora 安装渲染器hexo默认的渲染器是marked，并不支持mathjax。kramed是在marked基础上修改的，支持了mathjax。你的hexo工程目录下的node_modules中可以找到对应的渲染器文件夹。同时在你的工程目录下用以下命令安装kramed。另外补充一个NexT配置中推荐的渲染器hexo-renderer-pandoc，功能很强大不仅可以渲染markdown，还支持textile、reStructedText等许多其他格式。具体参见官方教程 123npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save// npm install hexo-renderer-pandoc --save 如果你安装了hexo-math包，卸载再安装hexo-renderer-mathjax包 12npm uninstall hexo-math --savenpm install hexo-renderer-mathjax --save 更新mathjax的CDN链接，打开node_modules/hexo-renderer-mathjax/mathjax.html 修改&lt;scripts&gt;标签 1&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"&gt;&lt;/script&gt; NexT开启mathjax打开主题的_config.yml文件，找到math字段，新版的NexT主题支持两个数学渲染引擎mathjax和katex，这里我们使用mathjax 1234math: enable: true // 省略很多注释 engine: mathjax 文章中开启mathjax标签为加快渲染速度，渲染器只会在标签中有mathjax: true的文章中使用利用mathjax渲染。例： 1234title: hexo支持mathjaxdate: 2018-08-31 08:33:08tags: [Web,hexo,mathjax]mathjax: true // 开启后才会渲染数学公式 TypoareTypoare原生支持数学公式的输入和渲染，而且还支持本地图片导入的图片复制位置。 然后开启你的Typoare编辑器输入几串公式，看看效果吧~]]></content>
      <categories>
        <category>网站</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>hexo</tag>
        <tag>mathjax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贝塞尔曲线]]></title>
    <url>%2F2018%2F08%2F18%2F%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[贝塞尔曲线本文章借鉴自Unity中的曲线绘制. 贝塞尔曲线(Bézier curve)是由法国数学家Pierre Bézier所提出,类似于Photoshop软件中的钢笔工具,不过钢笔工具仅仅只是用了二阶贝塞尔曲线. 原理在我们写代码之前还是了解一下原理为好,所以贝塞尔曲线的原理就是利用经过所有直线上的点的差值来进行绘制,如图为二阶曲线 下面给出二阶曲线的公式,P0,P1,P2为示例图上三点,t为差值数据: B(t) = (1 - t)^2P_0 + 2t(1 - t)P_1 + t^2P_2 , t\epsilon[0,1]而一阶曲线自然就是一个直线,公式为: B(t) = P_0 + (P_1 - P_0)t = (1 - t)P_0 + tP_1 , t\epsilon[0,1]从中我们可以发现规律从而推导到n阶的公式: B(t) = \sum_{i=0}^nPi(1 -t)^{n-i}t^i , t\epsilon[0,1]而我们要在Scene窗口绘制出贝塞尔曲线,所以这里用到Editor类下的OnInspectorGUI函数绘制Inspector窗口中的贝塞尔曲线配置,OnSceneGUI函数中绘制真正的贝塞尔曲线,绘制方式我们利用Handles函数进行直线模拟曲线方式的绘制. 代码首先我们需要一个数据类Curve,存储简单的Vector3数组 12// 贝塞尔曲线数据public Vector3[] points; 然后我们需要一个Editor类这里我们起名为CurveTool,继承自Editor并重写刚才说的两个函数,此处代码不懂可以看我之前写过的文章: Unity编辑器 12345678public override void OnInspectorGUI()&#123; serializedObject.Update(); EditorGUILayout.BeginVertical(); EditorGUILayout.PropertyField(points, new GUIContent("坐标组"), true); EditorGUILayout.EndVertical(); serializedObject.ApplyModifiedProperties();&#125; 然后接下来时重写OnSceneGUI函数了,不过在之前我们要看看具体怎么用代码来实现刚才的N阶曲线.因为我们要利用直线来绘制,所以需要一个for循环来执行绘制,利用GetPoint函数来获取具体每个精度点的位置然后绘制直线就好了. 1234567Vector3 lineStart = GetPoint(0f); // GetPoint函数为获取当前点的位置for (int i = 1; i &lt;= curve.lineSteps; i++) // lineSteps为绘制精度&#123; Vector3 lineEnd = GetPoint(i / (float)curve.lineSteps); Handles.DrawLine(lineStart, lineEnd); lineStart = lineEnd;&#125; 每次取差值就能减少一阶,所以利用递归从n阶到最后的一阶然后的返回值就是最终点的位置. 123456789101112131415161718192021public Vector3 GetPoint(float t)&#123; Vector3[] pos = new Vector3[curve.points.Length]; pos = (Vector3[])curve.points.Clone(); return curve.transform.TransformPoint(GetLerpPoint(pos, t));&#125;public Vector3 GetLerpPoint(Vector3[] pos, float t)&#123; if (pos.Length == 2) &#123; return Vector3.Lerp(pos[0], pos[1], t); &#125; Vector3[] newPos = new Vector3[pos.Length - 1]; for (int i = 0; i &lt; pos.Length - 1; i++) &#123; newPos[i] = Vector3.Lerp(pos[i], pos[i + 1], t); &#125; return GetLerpPoint(newPos, t);&#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>C#</tag>
        <tag>BézierCurve</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[toLua踩坑篇]]></title>
    <url>%2F2018%2F07%2F29%2FtoLua%E8%B8%A9%E5%9D%91%E7%AF%87%2F</url>
    <content type="text"><![CDATA[toLua踩坑篇最近工作得用Lua实现逻辑，桥梁用的toLua，踩了很多坑，在这里记录一下。 坑~toLua解析Lua属性首先我们给出Lua文件的内容，基于toLua Examples 04修改： 1234567891011121314151617print('Objs2Spawn is: '..Objs2Spawn)var2read = 42varTable = &#123;1,2,3,4,5&#125;varTable.default = 1varTable.map = &#123;&#125;varTable.map.name = "map"meta = &#123;name = "meta"&#125;setmetatable(varTable, meta)function TestFunc() print('get func by variable')endfunction varTable.func() print("获取table中的函数")end 在展示坑之前先看看使用toLua，下面是解析全局变量的代码： 12LuaState lua = new LuaState();Debug.Log(lua["全局变量名"]); 缓存成函数类LuaFunction: 1LuaFunction func = lua.GetFunction("函数名"); 缓存成表类LuaTable: 1LuaTable table = lua.GetTable("表名"); 那么下面开始踩坑，上代码： 123456789101112131415161718192021222324252627282930313233// 声明lua解析器对象LuaState lua = new LuaState();lua.Start();// 添加lua执行路径lua.AddSearchPath(Application.dataPath + "/Lua");// 将Objs2Spawn存到lua的全局变量中并赋值lua["Objs2Spawn"] = 5;// 寻找文件并执行，如找到则返回一个对象。lua.DoFile("CallLuaFunction.lua");// 寻找文件并执行，第一次生成对象返回，之后返回之前生成过的对象。lua.Require("AccessingLuaVariables");// 通过LuaState访问Debug.Log(lua["var2read"]); // 输出-&gt; 42Debug.Log(lua["varTable.default"]); // 输出-&gt; 1// 直接利用LuaState获取nameDebug.Log(lua["varTable.map.name"]); // 输出-&gt; mapLuaFunction func = lua["TestFunc"] as LuaFunction;func.Call();func = lua["varTable.func"] as LuaFunction;func.Call();func.Dispose();//cache成LuaTable访问LuaTable table = lua.GetTable("varTable");Debug.Log(table["default"]); // 输出-&gt; 1// 利用Table获取name，有BugDebug.Log(table["map.name"]); // 输出-&gt; NullLuaTable table1 = table.GetTable&lt;LuaTable&gt;("map");// 利用Table的Table获取nameDebug.Log(table1["name"]); // 输出-&gt; map 最后的结果为： 图中显示代码table[“map.name”]的结果为Null，这里是toLua的一个bug，在缓存成table的时候处理table中的table有些问题。解决方式上面的代码也给了，就是从table中再获取table，实在是非常的麻烦，还有个简单的方式为直接利用LuaState获取。 坑~Lua函数解析这里利用的是toLua Examples 03的内容作了一些修改，首先还是看Lua代码： 123456789101112131415161718192021222324CallLuaFunction = &#123;&#125;function CallLuaFunction.func1() print("Call Lua Function")endfunction CallLuaFunction.func2(num1, num2) print("执行func2") return num1 + num2endfunction CallLuaFunction.func3(num) return num + 1endfunction CallLuaFunction.func4(num) print("执行func4 " .. num)endfunction CallLuaFunction:func5() self.a = 1 self.b = 2 print(self.a .. " " .. self.b)end 这里一共有5个函数，我们分别针对这五个函数的解析做一些展示。首先是func1，这个函数没有任何的参数也没有返回值，所以调用它很简单（这里假设已经做完lua的建立和释放工作）： 1234// 获取Lua函数LuaFunction func = lua.GetFunction("CallLuaFunction.func1");// 执行函数，无返回值，最多支持9个参数func.Call(); 对于func2的函数，有两个参数和返回值，这里给出了示例中的4种执行方式，这里坑就来了 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 注：必须进行委托初始化才能执行方式1，3，4DelegateFactory.Init();func = lua.GetFunction("CallLuaFunction.func2");if (func != null)&#123; // 第一种方式 // 执行函数，有返回值，最多支持9个参数1个返回值 int num = func.Invoke&lt;int, int, int&gt;(10, 20); Debug.Log(num); // 第二种方式 num = CallFunc(func); Debug.Log(num); // 第三种方式 // 向LuaFunction中添加委托，利用委托实现函数返回 // 注：此委托ToLua作者并没有给，所以得自己补充 // 作者只给了Func&lt;int, int&gt;的委托 Func&lt;int, int, int&gt; luaFunc = func.ToDelegate&lt;Func&lt;int, int, int&gt;&gt;(); num = luaFunc(10, 20); Debug.Log(num); // 第四种方式 // 直接利用LuaState执行函数，最多6个参数1个返回值 num = lua.Invoke&lt;int, int, int&gt;("CallLuaFunction.func2", 10, 20, true); Debug.Log(num);&#125;private int CallFunc(LuaFunction func)&#123; // 函数开始 func.BeginPCall(); // 传第一个参 func.Push(10); // 传第二个参 func.Push(20); // 执行函数 func.PCall(); // 检查返回值 int num = (int)func.CheckNumber(); // 结束函数 func.EndPCall(); return num;&#125; 再执行到第三种方式的时候会报错，提示no register（未注册），这是为什么呢？因为代码中会注册委托，再进行调用，而Func并没有被注册，所以报错了。这里我们知道原因了，那就自己加一个注册呗，说干就干： DelegateFactory脚本的Register方法控制的委托注册在里面加上一行： 1DelegateTraits&lt;System.Func&lt;int,int,int&gt;&gt;.Init(factory.System_Func_int_int_int); 同是在DelegateFactory脚本中我们添加System_Func_int_int_int函数： 1234567891011121314151617181920212223public System.Func&lt;int, int, int&gt; System_Func_int_int_int(LuaFunction func, LuaTable self, bool flag)&#123; if (func == null) &#123; System.Func&lt;int, int, int&gt; fn = delegate (int param0, int param1) &#123; return 0; &#125;; return fn; &#125; if (!flag) &#123; System_Func_int_int_int_Event target = new System_Func_int_int_int_Event(func); System.Func&lt;int, int, int&gt; d = target.Call; target.method = d.Method; return d; &#125; else &#123; System_Func_int_int_int_Event target = new System_Func_int_int_int_Event(func, self); System.Func&lt;int, int, int&gt; d = target.CallWithSelf; target.method = d.Method; return d; &#125;&#125; 到这里我们还缺少System_Func_int_int_int_Event类，也同是在DelegateFactory脚本中添加： 12345678910111213141516171819202122232425262728class System_Func_int_int_int_Event : LuaDelegate&#123; public System_Func_int_int_int_Event(LuaFunction func) : base(func) &#123; &#125; public System_Func_int_int_int_Event(LuaFunction func, LuaTable self) : base(func, self) &#123; &#125; public int Call(int param0, int param1) &#123; func.BeginPCall(); func.Push(param0); func.Push(param1); func.PCall(); int ret = (int)func.CheckNumber(); func.EndPCall(); return ret; &#125; public int CallWithSelf(int param0, int param1) &#123; func.BeginPCall(); func.Push(self); func.Push(param0); func.Push(param1); func.PCall(); int ret = (int)func.CheckNumber(); func.EndPCall(); return ret; &#125;&#125; 坑就这样踩过去了，运行以下，你会发现不会报错并且执行也是正确的了。 接下来是func3函数，一个参数，这个就不用多说了与func2一样的。 之后是func4函数，这里就展示一下func2中的最后一种执行方式，不过没有返回值： 1lua.Call&lt;int&gt;("CallLuaFunction.func4", 10, true); 最后的func5就很神奇了，哪里神奇呢？你注意到表名和函数名的连接处用的是”:”了么，这里与”.”的区别就是会传入self，相当于C#中的this，那又会说了func5不是没有参数么，因为self是隐式的传入，如果你从C#调用它，必须得传这个参数。坑，这里用GetTable解决一下，感觉很麻烦，不过toLua应该是内置了”:”函数的形式。 123LuaTable table = lua.GetTable("CallLuaFunction");lua.Call&lt;LuaTable&gt;("CallLuaFunction.func5", table, true);Debug.Log(table["a"]);]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>C#</tag>
        <tag>toLua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity编辑器]]></title>
    <url>%2F2018%2F07%2F24%2FUnity%E7%BC%96%E8%AF%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Unity编辑器这篇文章主要总结一下最近工作时写的一些编辑器，总结了三种常用的编辑器编写方式： Inspector Editor EditorWindow ScriptableWizard Inspector Editor利用CustomEditor特性挂接Script来实现Inspector界面显示 首先我们给出对应的Script代码，主要是为了提供Inspector面板的参数而用 12345678public class SampleEditorScript : MonoBehaviour&#123; public int sliderNum = 0; public int intNum = 0; public float floatNum = 0f; public string str = ""; public Vector2 pos = Vector2.zero;&#125; 之后写对应的Editor文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 脚本为前面编写的数据脚本[CustomEditor(typeof(SampleEditorScript))]// [CanEditMultipleObjects] 多对象编辑public class SampleEditor : Editor&#123; SerializedProperty sliderNum; SerializedProperty intNum; SerializedProperty floatNum; SerializedProperty str; SerializedProperty pos; void OnEnable() &#123; // 将值传给对应的SerializedProperty sliderNum = serializedObject.FindProperty("sliderNum"); intNum = serializedObject.FindProperty("intNum"); floatNum = serializedObject.FindProperty("floatNum"); str = serializedObject.FindProperty("str"); pos = serializedObject.FindProperty("pos"); &#125; /// &lt;summary&gt; /// 绘制Inspector窗口 /// &lt;/summary&gt; public override void OnInspectorGUI() &#123; // 每次绘制insperctor面板的时候都应该更新一下serializedObjectd的数据 serializedObject.Update(); // 除PropertyField函数外，正常函数也封装了传入SerializedProperty的用法 EditorGUILayout.IntSlider(sliderNum, 0, 100, new GUIContent("Slider")); ProgressBar(sliderNum.intValue / 100.0f, "Slider Num"); // PropertyField好处为自动识别类型 EditorGUILayout.PropertyField(intNum, new GUIContent("Int Num")); EditorGUILayout.PropertyField(floatNum, new GUIContent("Float Num")); EditorGUILayout.PropertyField(str, new GUIContent("string")); EditorGUILayout.PropertyField(pos, new GUIContent("Vector2")); // 将数据更改应用于serializedObject serializedObject.ApplyModifiedProperties(); &#125; /// &lt;summary&gt; /// 绘制Scene窗口 /// &lt;/summary&gt; void OnSceneGUI() &#123; // 绘制的线为红色 Handles.color = Color.red; // 在点(0,0,0)到(1,1,1)画一条红线 Handles.DrawLine(Vector3.zero, Vector3.one); &#125; /// &lt;summary&gt; /// 自定义进度条 /// &lt;/summary&gt; /// &lt;param name="value"&gt;进度条值&lt;/param&gt; /// &lt;param name="label"&gt;进度条名字&lt;/param&gt; void ProgressBar(float value, string label) &#123; // 为文本框绘制一个进度条 Rect rect = GUILayoutUtility.GetRect(18, 18, "TextField"); EditorGUI.ProgressBar(rect, value, label); EditorGUILayout.Space(); &#125;&#125; EditorWindow创建一个编辑器视窗，视窗可以内嵌到Unity编辑器中 12345678910111213141516171819202122232425262728293031323334353637383940public class SampleEditorWindow : EditorWindow&#123; private int intNum = 0; private float floatNum = 0f; private string str = ""; private Vector2 SVPos; /// &lt;summary&gt; /// 菜单栏响应函数 /// &lt;/summary&gt; [MenuItem("EditorTools/SampleEditorWindow")] static void Init() &#123; // 初始化窗口并显示 SampleEditorWindow window = (SampleEditorWindow)GetWindow(typeof(SampleEditorWindow)); window.Show(); &#125; /// &lt;summary&gt; /// 界面绘制函数 /// &lt;/summary&gt; void OnGUI() &#123; // 绘制可用EditorGUILayout、GUILayout所提供的函数等 // 竖直排版 EditorGUILayout.BeginHorizontal(); // 滑动组件 SVPos = EditorGUILayout.BeginScrollView(SVPos); // int输入框 intNum = EditorGUILayout.IntField("Int Num", intNum); // float输入框 floatNum = EditorGUILayout.FloatField("Float Num", floatNum); // string输入框 str = EditorGUILayout.TextField("string", str); // 等等... EditorGUILayout.EndScrollView(); EditorGUILayout.EndHorizontal(); &#125;&#125; ScriptableWizard创建一个编辑器导航视窗 123456789101112131415161718192021222324252627282930313233public class SampleScriptableWizard : ScriptableWizard&#123; public int intNum = 0; public float floatNum = 0f; public string str = ""; [MenuItem("EditorTools/SampleScriptableWizard")] static void Init() &#123; ScriptableWizard.DisplayWizard&lt;SampleScriptableWizard&gt;("Wizard界面", "Wizard按钮", "Wizard另一个按钮"); &#125; /// &lt;summary&gt; /// 界面的刷新 /// &lt;/summary&gt; void OnWizardUpdate() &#123; helpString = "这是一条提示语句"; &#125; /// &lt;summary&gt; /// 按钮执行功能 /// &lt;/summary&gt; void OnWizardCreate() &#123; Debug.Log("点击按钮"); &#125; void OnWizardOtherButton() &#123; Debug.Log("点击另一个按钮"); &#125;&#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Unity Editor</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图形学Prelin噪声解析]]></title>
    <url>%2F2018%2F07%2F21%2F%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%99%AA%E5%A3%B0%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Prelin噪声Prelin噪声由Ken Perlin在1983年提出，因参与制作迪士尼的动画电影《电子世界争霸战》，但不满于当时那种非常不自然的纹理效果，而提出了Perlin噪声本篇文章借鉴各路大神的文章总结而来： 冯乐乐：【图形学】谈谈噪声 则卷大明：Unity3D教程：PerlinNoise原理及实现 Unity API：Mathf.PerlinNoise 此文章源码在我的个人GitHub上，本文章的仅仅实现了Prelin噪声中的最简单版本。上图先~ 利用Unity实现2D Prelin噪声candycat的文章非常好，不过没有Unity的具体实现代码，而则卷大明的文章中只给出了一部分的代码。最后发现了Unity自带2D噪声，所以结合多方文章最终完成了最简单的Prelin噪声。 如果你懂GLSL的pixel shaders，那你就可以直接去阅读由iq大神写的：Voronoise。而这里我只是用Unity代码还原冯乐乐博客中利用shaderToy编写的代码 在开始正文之前，我们得知道几个数学小知识。图形学中涉及矩阵计算的东西有太多，在ShaderToy中都有封装，而Unity并没有，所以我们得实现几个图形学函数 Floor：向下取整 1234private static Vector2 Floor(Vector2 p)&#123; return new Vector2(Mathf.Floor(p.x), Mathf.Floor(p.y));&#125; Fract：取小数部分 1234private static Vector2 Fract(Vector2 p)&#123; return p - Floor(p);&#125; Sin：正弦函数 1234private static Vector2 Sin(Vector2 p)&#123; return new Vector2(Mathf.Sin(p.x), Mathf.Sin(p.y));&#125; 其实这些函数在Unity中也有实现，不过我这里要实现2D的噪声，所以得处理2D情况下的操作。接下来就是正片了~首先还原冯乐乐博客中的梯度函数 1234567private static Vector2 Hash22(Vector2 p)&#123; p = new Vector2(Vector2.Dot(p, new Vector2(127.1f, 311.7f)), Vector2.Dot(p, new Vector2(269.5f, 183.3f))); return new Vector2(-1, -1) + 2.0f * Fract(Sin(p) * 43758.5453123f);&#125; 然后还原缓和曲线，这里利用新提出的缓和曲线，使其在二阶的情况下也能满足连续性，公式如下： s(t)=6*t^5-15*t^4+10*t^312345678910// 一阶private static float GetEaseCurves(float t)&#123; return t * t * t * (t * (t * 6 - 15) + 10);&#125;// 二阶private static Vector2 GetEaseCurves(Vector2 p)&#123; return new Vector2(GetEaseCurves(p.x), GetEaseCurves(p.y));&#125; 这里将冯乐乐中的-1.0f改为Unity中可计算的Vector(-1, -1)接下来是生成prelin噪声的主函数了 12345678910111213141516public static float prelin_noise(Vector2 p)&#123; Vector2 pi = Floor(p); Vector2 pf = p - pi; Vector2 w = GetEaseCurves(pf); float corner1 = Vector2.Dot(Hash22(pi + Vector2.zero), pf - Vector2.zero); float corner2 = Vector2.Dot(Hash22(pi + Vector2.right), pf - Vector2.right); float corner3 = Vector2.Dot(Hash22(pi + Vector2.up), pf - Vector2.up); float corner4 = Vector2.Dot(Hash22(pi + Vector2.one), pf - Vector2.one); return Mathf.Lerp(Mathf.Lerp(corner1, corner2, w.x), Mathf.Lerp(corner3, corner4, w.x), w.y);&#125; 到这里我们完成了2D Prelin噪声的构建，加下来就是怎么利用噪声生成贴图并转成PNG存储起来~下面的代码生成了一个噪声的贴图并且返回 12345678910111213141516171819202122232425262728293031private int width = 512; // 贴图宽度private int height = 512; // 贴图高度private float xOrg = 0f; // 宽度偏移起点private float yOrg = 0f; // 高度偏移起点private float scale = 15f; // 周期private Texture2D CreateTexture()&#123; Texture2D tex = new Texture2D(width, height); Color[] pix = new Color[width * height]; float y = 0f; while (y &lt; height) &#123; float x = 0f; while (x &lt; width) &#123; float xCoord = xOrg + x / width * scale; float yCoord = yOrg + y / height * scale; float sample = PrelinNoise.prelin_noise(new Vector2(xCoord, yCoord)); pix[(int)y * width + (int)x] = new Color(sample, sample, sample); x++; &#125; y++; &#125; tex.SetPixels(pix); tex.Apply(); return tex;&#125; 下面的函数将贴图转换成PNG图片存储到特定位置 123456789101112131415161718192021222324252627282930private bool SaveTexture(Texture2D tex, string path)&#123; if (File.Exists(path)) &#123; Debug.LogWarning("已有文件"); return false; &#125; if (tex == null) &#123; Debug.LogWarning("贴图为空"); return false; &#125; // 贴图转换为PNG图片 byte[] texData = tex.EncodeToPNG(); // 如果没有目录则创建目录 int index = path.LastIndexOf('/'); string dir = path.Remove(index); if (!Directory.Exists(dir)) &#123; Directory.CreateDirectory(dir); &#125; // 贴图存储 File.WriteAllBytes(path, texData); return true; &#125; 后续还会陆续更新Sample噪声，分型噪声等利用Unity实现的方式]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>C#</tag>
        <tag>Graphics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站的建立]]></title>
    <url>%2F2018%2F07%2F20%2F%E7%BD%91%E7%AB%99%E7%9A%84%E5%BB%BA%E7%AB%8B%2F</url>
    <content type="text"><![CDATA[开始很久之前就有创立网站的想法，不过就是一腔热血，弄到一半因为一些小问题就放弃了。这次吸取上一次的教训好好的弄一弄之前网站的雏形就是从candycat的GitHub博客上找的，她推荐了两个比较好用的网站，在这里我也列出来： CENALULU : 比较详细的介绍了利用jekyll建立网站的步骤 Huxpro : candycat的网站皮肤模板 不过这里我们不利用jekyll建立网站，想利用jekyll建立网站的可以参考上面两个教程经过哥们的介绍认识了另一个比较方便建立GitHub个人博客的工具Hexo 利用Hexo创建Github博客下载HexoHexo的运行需要两个前置的组件： Node.js : 是一个Javascript运行环境，对Chrome V8引擎进行了封装 Git : 是一个开源的分布式版本控制系统，基于GitHub的博客怎能缺少Git 开始建立博客注：以下操作都基于Window系统，本人系统win10 如果已经安装上述必备程序，接下来就是Hexo的安装了，打开CMD，敲击第一段代码 1npm install -g hexo-cli 等待安装完成后，以次执行以下代码 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 创建一个存放博客的本地仓库 进入到此仓库中 hexo会建立所需要的文件 然后可以利用如下代码，运行以下命令启动服务，在浏览器中输入localhost:4000看看效果 1hexo server 配置网站不论用jekyll或者hexo构建博客都会生成_config.yml的配置分解，里面大部分网站参数都是可配置的。关于配置的介绍点击这里。 皮肤Hexo官网就有很多的皮肤样式可供选择，链接。从中选择一个你喜欢的皮肤就进行配置吧，这里推荐一下我自己的皮肤Archer，皮肤的GitHub。 网站的部署利用以下的代码建立Hexo与Git的桥梁 1npm install hexo-deployer-git --save 利用以下代码来书写博客和提交博客 1234hexo new "文件名" // 建立博客的文章 等同于 hexo nhexo deloy // 部署到GitHub上 等同于 hexo dhexo generate // 提交本地仓库，类似于git的commit 等同于 hexo ghexo g -d // 提交加部署 hexo new 创建的文件将会存放到sorce/_post目录中。 利用ATOM书写MarkdownATOM是Git自家出品的IDE，功能很强大，利用Ctrl+Shift+M可以边写边看成品，非常方便。]]></content>
      <categories>
        <category>网站</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初记]]></title>
    <url>%2F2018%2F07%2F19%2F%E5%88%9D%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[新的开始这是一次记录也是一个开始，新博客的第一篇文章，经历的3天的摸索完成的网站的创建，虽然还有很多的细节没有完成但也非常的开心。就像我的签名那样“不忘初心，天道酬勤”，希望这句话伴随我一生，成为我的座右铭。让自己更上一层楼。第一篇文章预留一下，介绍一些网站建立的艰辛经历和过程。]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
